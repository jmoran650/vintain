This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-06T01:49:12.556Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
Backend/
  src/
    account/
      graphql/
        resolver.ts
        schema.ts
        service.ts
    auth/
      graphql/
        resolver.ts
        schema.ts
        service.ts
    common/
      decorators.ts
      types.ts
    database/
      sql/
        schema.sql
    listing/
      graphql/
        resolver.ts
        schema.ts
        service.ts
    message/
      graphql/
        resolver.ts
        schema.ts
        service.ts
    orders/
      graphql/
        resolver.ts
        schema.ts
        service.ts
    s3/
      graphql/
        resolver.ts
        schema.ts
        service.ts
  tests/
    domains/
      account/
        account.test.ts
      auth/
        check.test.ts
        login.test.ts
      common/
        db/
          reset.ts
      listing/
        listing.test.ts
      message/
        message.test.ts
      orders/
        orders.test.ts
    fixtures/
      data.sql
      schema.sql
    dbTest.ts
  babel.config.js
  db.ts
  index.ts
  jest.config.js
  package.json
  repomix-output.txt
  tsconfig.json
vintainApp/
  app/
    (tabs)/
      _layout.tsx
      createListing.tsx
      index.tsx
      profile.tsx
    _layout.tsx
    +not-found.tsx
    auth.tsx
    editProfile.tsx
    listingDetail.tsx
  components/
    __tests__/
      __snapshots__/
        ThemedText-test.tsx.snap
      ThemedText-test.tsx
    ui/
      IconSymbol.ios.tsx
      IconSymbol.tsx
      TabBarBackground.ios.tsx
      TabBarBackground.tsx
    Collapsible.tsx
    ExternalLink.tsx
    HapticTab.tsx
    HelloWave.tsx
    ParallaxScrollView.tsx
    ThemedText.tsx
    ThemedView.tsx
  constants/
    Colors.ts
  context/
    authContext.tsx
  hooks/
    useColorScheme.ts
    useColorScheme.web.ts
    useThemeColor.ts
  scripts/
    reset-project.js
  src/
    apiService.ts
    reactQuerySetup.ts
  .gitignore
  app.json
  package.json
  README.md
  repomix-output.txt
  tsconfig.json
.gitignore
docker-compose.yml
package.json
README.md

================================================================
Files
================================================================

================
File: Backend/src/account/graphql/resolver.ts
================
// src/account/graphql/resolver.ts
import { Authorized, Query, Resolver, Ctx, Mutation, Arg } from "type-graphql";
import { Request } from "express";
import { AccountService } from "./service";
import { Account, NewAccount } from "./schema";
import { UUID, Email } from "../../common/types";
import { Service } from "typedi";
import { Public } from "../../common/decorators";

@Service()
@Resolver()
export class AccountResolver {
  constructor(private readonly accountService: AccountService) {}

  @Authorized()
  @Query(() => Account)
  async account(
    @Ctx() _req: Request,
    @Arg("input") id: UUID
  ): Promise<Account> {
    return this.accountService.getAccount(id);
  }

  @Authorized()
  @Query(() => Account)
  async accountByEmail(
    @Ctx() _req: Request,
    @Arg("input") email: Email
  ): Promise<Account> {
    return this.accountService.getAccountByEmail(email.toLowerCase());
  }

  @Authorized()
  @Query(() => [Account])
  async allAccounts(@Ctx() _req: Request): Promise<Account[]> {
    return this.accountService.getAllAccounts();
  }

  @Authorized()
  @Query(() => [Account])
  async restrictedVendors(@Ctx() _req: Request): Promise<Account[]> {
    const all = await this.accountService.getAllAccounts();
    return all.filter((acc) => acc.restricted && acc.roles.includes("Vendor"));
  }

  // Public operation: account creation is marked as public via decorator.
  @Public()
  @Mutation(() => Account)
  async makeAccount(
    @Arg("input") newAccount: NewAccount,
    @Ctx() _request: Request
  ): Promise<Account> {
    newAccount.email = newAccount.email.toLowerCase();
    return this.accountService.makeAccount(newAccount);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteAccount(
    @Arg("input") accountID: UUID,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return this.accountService.deleteAccount(accountID);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteAccountByEmail(
    @Arg("input") accountEmail: Email,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return this.accountService.deleteAccountByEmail(accountEmail.toLowerCase());
  }

  @Authorized()
  @Mutation(() => Boolean)
  async suspendAccount(
    @Arg("input") accountID: UUID,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return this.accountService.suspendAccount(accountID);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async suspendAccountByEmail(
    @Arg("input") accountEmail: Email,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return this.accountService.suspendAccountByEmail(accountEmail.toLowerCase());
  }

  @Authorized()
  @Mutation(() => Boolean)
  async resumeAccount(
    @Arg("input") accountID: UUID,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return this.accountService.resumeAccount(accountID);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async resumeAccountByEmail(
    @Arg("input") accountEmail: Email,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return this.accountService.resumeAccountByEmail(accountEmail.toLowerCase());
  }

// src/account/graphql/resolver.ts (partial change)

@Authorized()
@Mutation(() => Boolean)
async updateProfile(
  @Arg("id") id: UUID,
  @Arg("username", { nullable: true }) username?: string,
  @Arg("bio", { nullable: true }) bio?: string,
  // New optional argument:
  @Arg("profilePicture", { nullable: true }) profilePicture?: string
): Promise<boolean> {
  return this.accountService.updateProfile(id, username, bio, profilePicture);
}

}

================
File: Backend/src/account/graphql/schema.ts
================
// src/account/graphql/schema.ts
import { ObjectType, InputType, Field } from "type-graphql";
import { MinLength } from "class-validator";
import { Name, UUID, Email } from "../../common/types";

// src/account/graphql/schema.ts

@ObjectType()
export class Profile {
  @Field()
  @MinLength(1)
  username!: string;

  @Field({ nullable: true })
  bio?: string;

  // New field for profile picture URL
  @Field({ nullable: true })
  profilePicture?: string;
}

/**
 * The Account object includes a non-null profile.
 */
@ObjectType()
export class Account {
  @Field()
  id!: UUID;

  @Field()
  email!: Email;

  @Field()
  name!: Name;

  @Field(() => [String])
  roles!: string[];

  @Field()
  restricted!: boolean;

  @Field(() => Profile)
  profile!: Profile;
}

/**
 * Input for creating a new account.
 */
@InputType()
export class NewAccount {
  @Field()
  email!: Email;

  @Field()
  @MinLength(1)
  password!: string;

  @Field()
  @MinLength(1)
  firstName!: string;

  @Field()
  @MinLength(1)
  lastName!: string;

  @Field(() => [String])
  roles!: string[];

  @Field()
  @MinLength(1)
  username!: string;

  @Field({ nullable: true })
  bio?: string;
}

================
File: Backend/src/account/graphql/service.ts
================
// src/account/graphql/service.ts

import { Service } from "typedi";
import { pool } from "../../../db";
import { NewAccount, Account } from "./schema";
import { UUID, Email } from "../../common/types";

@Service()
export class AccountService {
  public async getAccount(id: UUID): Promise<Account> {
    const select = `
      SELECT
        id,
        email,
        restricted,
        data->'name' AS name,
        data->'roles' AS roles,
        data->'profile' AS profile
      FROM account
      WHERE id = $1
    `;
    const { rows } = await pool.query(select, [id]);

    if (rows.length === 0) {
      throw new Error("Account with given ID does not exist.");
    }

    const row = rows[0];
    return {
      id: row.id,
      email: row.email,
      restricted: row.restricted,
      name: row.name,
      roles: row.roles || [],
      profile: {
        username: row.profile?.username ?? "",
        bio: row.profile?.bio ?? null,
      },
    };
  }

  public async getAccountByEmail(email: Email): Promise<Account> {
    const select = `
      SELECT
        id,
        email,
        restricted,
        data->'name' as name,
        data->'roles' as roles,
        data->'profile' as profile
      FROM account
      WHERE email = $1
    `;
    const { rows } = await pool.query(select, [email]);

    if (rows.length === 0) {
      throw new Error("Account with given Email does not exist.");
    }

    const row = rows[0];
    return {
      id: row.id,
      email: row.email,
      restricted: row.restricted,
      name: row.name,
      roles: row.roles || [],
      profile: {
        username: row.profile?.username ?? "",
        bio: row.profile?.bio ?? null,
      },
    };
  }

  public async getAllAccounts(): Promise<Account[]> {
    const select = `
      SELECT
        id,
        email,
        restricted,
        data->'name' as name,
        data->'roles' as roles,
        data->'profile' as profile
      FROM account
    `;
    const { rows } = await pool.query(select);

    return rows.map((row: any) => ({
      id: row.id,
      email: row.email,
      restricted: row.restricted,
      name: row.name,
      roles: row.roles || [],
      profile: {
        username: row.profile?.username ?? "",
        bio: row.profile?.bio ?? null,
      },
    }));
  }

  public async makeAccount(info: NewAccount): Promise<Account> {
    const restrictedVal = info.roles.some(
      (role) => role.toLowerCase() === "vendor"
    );

    // Explicitly cast parameters so that PostgreSQL can infer types.
    const insert = `
      INSERT INTO account (email, restricted, data)
      VALUES (
        $1::text,
        $7,
        jsonb_build_object(
          'name', jsonb_build_object(
            'first', $2::text,
            'last', $3::text
          ),
          'password', crypt($4::text, '${process.env.CRYPT_SECRET}'),
          'roles', $5::text[],
          'profile', jsonb_build_object(
            'username', $6::text,
            'bio', $8::text
          )
        )
      )
      RETURNING id
    `;
    const values = [
      info.email,
      info.firstName,
      info.lastName,
      info.password,
      info.roles,
      info.username,
      restrictedVal,
      info.bio || null,
    ];
    const { rows } = await pool.query(insert, values);

    return {
      id: rows[0].id,
      email: info.email,
      name: { first: info.firstName, last: info.lastName },
      roles: info.roles,
      restricted: restrictedVal,
      profile: {
        username: info.username,
        bio: info.bio || undefined,
      },
    };
  }

  public async deleteAccount(id: UUID): Promise<boolean> {
    const del = `DELETE FROM account WHERE id = $1`;
    await pool.query(del, [id]);
    return true;
  }

  public async deleteAccountByEmail(email: string): Promise<boolean> {
    const del = `DELETE FROM account WHERE email = $1`;
    await pool.query(del, [email]);
    return true;
  }

  private async modifyRestricted(
    byWhat: "id" | "email",
    setTo: boolean,
    byValue: UUID | Email
  ) {
    const update = `UPDATE account SET restricted = $2 WHERE ${byWhat} = $1`;
    await pool.query(update, [byValue, setTo]);
    return true;
  }

  public async suspendAccount(id: UUID): Promise<boolean> {
    return this.modifyRestricted("id", true, id);
  }

  public async resumeAccount(id: UUID): Promise<boolean> {
    return this.modifyRestricted("id", false, id);
  }

  public async suspendAccountByEmail(email: Email): Promise<boolean> {
    return this.modifyRestricted("email", true, email);
  }

  public async resumeAccountByEmail(email: Email): Promise<boolean> {
    return this.modifyRestricted("email", false, email);
  }

  public async updateProfile(
    id: UUID,
    username?: string,
    bio?: string,
    profilePicture?: string
  ): Promise<boolean> {
    // Retrieve the current profile
    const select = `
      SELECT data->'profile' as profile
      FROM account
      WHERE id = $1
    `;
    const { rows } = await pool.query(select, [id]);

    if (rows.length === 0) {
      throw new Error("No account found for that ID.");
    }

    const oldProfile = rows[0].profile || {};
    // Merge new values if provided
    const newProfile = {
      ...oldProfile,
      ...(username !== undefined ? { username } : {}),
      ...(bio !== undefined ? { bio } : {}),
      ...(profilePicture !== undefined ? { profilePicture } : {}),
    };

    const updateSql = `
      UPDATE account
      SET data = jsonb_set(
        data,
        '{profile}',
        $2::jsonb,
        true
      )
      WHERE id = $1
    `;
    await pool.query(updateSql, [id, JSON.stringify(newProfile)]);
    return true;
  }
}

================
File: Backend/src/auth/graphql/resolver.ts
================
// src/auth/graphql/resolver.ts
import { Resolver, Mutation, Query, Ctx, Arg } from "type-graphql";
import { Authenticated, Credentials, SessionAccount } from "./schema";
import { AuthService } from "./service";
import { Service } from "typedi";
import { Request } from "express";

@Service()
@Resolver()
export class AuthResolver {
  constructor(private readonly authService: AuthService) {}

  @Mutation(() => Authenticated)
  async login(
    @Ctx() req: Request,
    @Arg("input") creds: Credentials
  ): Promise<Authenticated> {
    const account = await this.authService.login(creds);
    if (!account) {
      throw new Error("Invalid Credentials");
    }
    return account;
  }

  @Query(() => SessionAccount)
  async check(
    @Ctx() req: Request,
    @Arg("input") accessToken: string
  ): Promise<SessionAccount> {
    return this.authService.check(accessToken);
  }
}

================
File: Backend/src/auth/graphql/schema.ts
================
//Backend/src/auth/graphql/schema.ts
import { ObjectType, InputType, Field } from "type-graphql";
import {MinLength} from 'class-validator';
import {UUID, Email, Name } from '../../common/types'



@InputType()
@ObjectType()
export class Authenticated {
  @Field()
  @MinLength(1)
  id!:string

  @Field()
  name!:Name

  @Field()
  @MinLength(1)
  accessToken!:string
}

ObjectType()
export class Account {
  @Field()
  id!:UUID

  @Field()
  email!:Email

  @Field()
  name!:Name

  @Field()
  @MinLength(1)
  accessToken!:string

  // TODO: IMPLEMENT TWO TOKENS AUTH
  // @Field()
  // @MinLength(1)
  // refreshToken!:string

}

@InputType()
@ObjectType()
export class Credentials {
  @Field()
  @MinLength(1)
  email!:Email

  @Field()
  @MinLength(1)
  password!:string

}

@InputType()
@ObjectType()
export class SessionAccount {

  @Field()
  @MinLength(1)
  id!: string;

}

================
File: Backend/src/auth/graphql/service.ts
================
// src/auth/graphql/service.ts
import { Service } from "typedi";
import { pool } from "../../../db";
import * as jwt from "jsonwebtoken";
import { Credentials, Authenticated, Account, SessionAccount } from "./schema";

@Service()
export class AuthService {
  private async find(creds: Credentials): Promise<Account | undefined> {
    const select = `SELECT id, email, data->'name' as name, data->'roles' as roles FROM account 
      WHERE email = $1 AND
      (data->>'password') = crypt($2, '${process.env.CRYPT_SECRET}') AND restricted = FALSE`;
    const { rows } = await pool.query(select, [creds.email, creds.password]);
    if (rows.length !== 1) {
      return undefined;
    }
    return rows[0];
  }

  public async login(creds: Credentials): Promise<Authenticated | undefined> {
    const account = await this.find(creds);
    if (!account) {
      return undefined;
    }
    const accessToken = jwt.sign(
      {
        id: account.id,
      },
      process.env.MASTER_SECRET as string,
      { algorithm: "HS256" }
    );

    return { id: account.id, name: account.name, accessToken };
  }

  public async check(accessToken: string): Promise<SessionAccount> {
    return new Promise((resolve, reject) => {
      jwt.verify(
        accessToken,
        process.env.MASTER_SECRET as string,
        (err, decoded) => {
          if (err) {
            return reject(err);
          }
          const account = decoded as { id: string };
          resolve({ id: account.id });
        }
      );
    });
  }
}

================
File: Backend/src/common/decorators.ts
================
// src/common/decorators/Public.ts
import "reflect-metadata";

export const IS_PUBLIC_KEY = "isPublic";

/**
 * Marks a resolver method as public (i.e. does not require authentication).
 */
export function Public(): MethodDecorator {
  return (target, propertyKey, descriptor) => {
    Reflect.defineMetadata(IS_PUBLIC_KEY, true, descriptor.value!);
  };
}

================
File: Backend/src/common/types.ts
================
// src/common/types.ts
import { ObjectType, Field, InputType } from "type-graphql";
import { MinLength } from "class-validator";

@ObjectType()
export class Name {
  @Field()
  @MinLength(1)
  first!: string;

  @Field()
  @MinLength(1)
  last!: string;
}

/**
 * From https://tsoa-community.github.io/docs/examples.html
 * Stringified UUIDv4.
 * See [RFC 4112](https://tools.ietf.org/html/rfc4122)
 * @pattern [0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}
 * @format uuid
 */
export type UUID = string;

/**
 * From https://tsoa-community.github.io/docs/examples.html
 * Stringified UUIDv4.
 * See [RFC 4112](https://tools.ietf.org/html/rfc4122)
 * @pattern ^[\w-.]+@([\w-]+\.)+[\w-]{2,4}$
 * @format email
 */
export type Email = string;

================
File: Backend/src/database/sql/schema.sql
================
--Backend/src/database/sql/schema.sql
-- 2.schema.sql
-- Enable pgcrypto for UUID generation and crypt()
CREATE EXTENSION IF NOT EXISTS pgcrypto;

DROP TABLE IF EXISTS account CASCADE;
-- Create the account table
CREATE TABLE account (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text UNIQUE NOT NULL,
  data jsonb NOT NULL,
  restricted boolean NOT NULL DEFAULT false
);

CREATE TABLE listing (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id uuid NOT NULL,
  data jsonb NOT NULL
);

CREATE TABLE message (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  item_owner_id uuid NOT NULL,
  sender_id uuid NOT NULL,
  data jsonb NOT NULL
);

DROP TABLE IF EXISTS orders CASCADE;

CREATE TABLE orders (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- The account who placed the order
  buyer_id uuid NOT NULL,
  
  -- The account (shop or seller) fulfilling the order
  seller_id uuid NOT NULL,
  
  -- For now, we’ll store an order or shipping status as a simple text column
  shipping_status text NOT NULL DEFAULT 'pending',

  item_id uuid NOT NULL,
  
  -- Possibly a JSONB for extra data (items, totals, addresses, etc.)
  data jsonb,
  
  CONSTRAINT fk_order_buyer
    FOREIGN KEY (buyer_id)
    REFERENCES account (id)
    ON DELETE CASCADE,

  CONSTRAINT fk_order_seller
    FOREIGN KEY (seller_id)
    REFERENCES account (id)
    ON DELETE CASCADE,
  
  CONSTRAINT fk_order_item
    FOREIGN KEY (item_id)
    REFERENCES listing (id)
);

================
File: Backend/src/listing/graphql/resolver.ts
================
// src/listing/graphql/resolver.ts

import { Authorized, Query, Resolver, Mutation, Arg, Int, Ctx } from "type-graphql";
import { Request } from "express";
import { ListingService } from "./service";
import { Listing, NewListing, PaginatedListings } from "./schema";
import { UUID } from "../../common/types";
import { Service } from "typedi";

@Service()
@Resolver()
export class ListingResolver {
  constructor(private readonly listingService: ListingService) {}

  @Authorized()
  @Query(() => Listing)
  async listing(
    @Ctx() _req: Request,
    @Arg("id") id: UUID
  ): Promise<Listing> {
    return this.listingService.getListing(id);
  }

  @Authorized()
  @Query(() => PaginatedListings)
  async allListings(
    @Ctx() _req: Request,
    @Arg("page", () => Int, { defaultValue: 1 }) page: number,
    @Arg("pageSize", () => Int, { defaultValue: 10 }) pageSize: number
  ): Promise<PaginatedListings> {
    return this.listingService.getAllListings(page, pageSize);
  }

  @Authorized()
  @Mutation(() => Listing)
  async createListing(
    @Arg("input") listingInfo: NewListing,
    @Ctx() _req: Request
  ): Promise<Listing> {
    return this.listingService.createListing(listingInfo);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteListing(
    @Arg("id") listingId: UUID,
    @Ctx() _req: Request
  ): Promise<boolean> {
    return this.listingService.deleteListing(listingId);
  }

  @Authorized()
  @Query(() => PaginatedListings)
  async searchListings(
    @Arg("searchTerm") searchTerm: string,
    @Arg("page", () => Int, { defaultValue: 1 }) page: number,
    @Arg("pageSize", () => Int, { defaultValue: 10 }) pageSize: number
  ): Promise<PaginatedListings> {
    const { listings, totalCount } = await this.listingService.searchListings(
      searchTerm,
      page,
      pageSize
    );
    return { listings, totalCount };
  }

  // In src/listing/graphql/resolver.ts, add:
  @Authorized()
  @Mutation(() => Boolean)
  async updateListingImages(
    @Arg("id") id: UUID,
    @Arg("imageUrls", () => [String]) imageUrls: string[]
  ): Promise<boolean> {
    return this.listingService.updateListingImages(id, imageUrls);
  }


}

================
File: Backend/src/listing/graphql/schema.ts
================
// src/listing/graphql/schema.ts

import { Field, InputType, ObjectType, Int } from "type-graphql";
import { MinLength } from "class-validator";
import { UUID } from "../../common/types";

@ObjectType()
export class Listing {
  @Field()
  id!: UUID;

  @Field()
  ownerId!: UUID;

  @Field()
  @MinLength(1)
  brand!: string;

  @Field()
  @MinLength(1)
  name!: string;

  @Field()
  @MinLength(1)
  description!: string;

  @Field(() => [String])
  imageUrls!: string[];
}

@InputType()
export class NewListing {
  @Field()
  ownerId!: UUID;

  @Field()
  @MinLength(1)
  brand!: string;

  @Field()
  @MinLength(1)
  name!: string;

  @Field()
  @MinLength(1)
  description!: string;

  @Field(() => [String])
  imageUrls!: string[];
}

/**
 * For returning paginated listing results (listings + totalCount).
 */
@ObjectType()
export class PaginatedListings {
  @Field(() => [Listing])
  listings!: Listing[];

  @Field(() => Int)
  totalCount!: number;
}

================
File: Backend/src/listing/graphql/service.ts
================
// src/listing/graphql/service.ts

import { Service } from "typedi";
import { pool } from "../../../db";
import { NewListing, Listing, PaginatedListings } from "./schema";
import { UUID } from "../../common/types";

@Service()
export class ListingService {
  /**
   * Fetch all listings with pagination.
   * @param page The page number (>= 1).
   * @param pageSize The number of listings per page (>= 1).
   * Returns { listings, totalCount }.
   */
  public async getAllListings(
    page: number = 1,
    pageSize: number = 10
  ): Promise<PaginatedListings> {
    if (page < 1) page = 1;
    if (pageSize < 1) pageSize = 10;

    const offset = (page - 1) * pageSize;

    const countResult = await pool.query(`SELECT COUNT(*) AS total FROM listing`);
    const totalCount = parseInt(countResult.rows[0].total, 10);

    const select = `
      SELECT
        id,
        owner_id as "ownerId",
        data->>'brand' as brand,
        data->>'name' as name,
        data->>'description' as description,
        data->'imageUrls' as "imageUrls"
      FROM listing
      LIMIT $1
      OFFSET $2
    `;

    const { rows } = await pool.query(select, [pageSize, offset]);

    const listings = rows.map((row: any) => ({
      ...row,
      imageUrls: row.imageUrls || [],
    }));

    return { listings, totalCount };
  }

  /**
   * Get a single listing by ID.
   */
  public async getListing(id: UUID): Promise<Listing> {
    const select = `
      SELECT
        id,
        owner_id as "ownerId",
        data->>'brand' as brand,
        data->>'name' as name,
        data->>'description' as description,
        data->'imageUrls' as "imageUrls"
      FROM listing
      WHERE id = $1
    `;
    const { rows } = await pool.query(select, [id]);
    if (rows.length === 0) {
      throw new Error("Listing with given ID does not exist.");
    }
    rows[0].imageUrls = rows[0].imageUrls || [];
    return rows[0];
  }

  /**
   * Create a new listing.
   */
  public async createListing(info: NewListing): Promise<Listing> {
    const insert = `
      INSERT INTO listing (owner_id, data)
      VALUES (
        $1::uuid,
        jsonb_build_object(
          'brand', $2::text,
          'name', $3::text,
          'description', $4::text,
          'imageUrls', $5::text[]
        )
      )
      RETURNING id;
    `;
    const { rows } = await pool.query(insert, [
      info.ownerId,
      info.brand,
      info.name,
      info.description,
      info.imageUrls,
    ]);

    return {
      id: rows[0].id,
      ownerId: info.ownerId,
      brand: info.brand,
      name: info.name,
      description: info.description,
      imageUrls: info.imageUrls,
    };
  }

  /**
   * Delete a listing by ID.
   */
  public async deleteListing(id: UUID): Promise<boolean> {
    const del = `DELETE FROM listing WHERE id = $1`;
    await pool.query(del, [id]);
    return true;
  }

  /**
   * Search by substring in brand/name/description (case-insensitive) with pagination.
   */
  public async searchListings(
    searchTerm: string,
    page: number = 1,
    pageSize: number = 10
  ): Promise<PaginatedListings> {
    if (page < 1) page = 1;
    if (pageSize < 1) pageSize = 10;

    const ilikeValue = `%${searchTerm}%`;

    const countSql = `
      SELECT COUNT(*) AS total
      FROM listing
      WHERE
        (data->>'brand') ILIKE $1
        OR (data->>'name') ILIKE $1
        OR (data->>'description') ILIKE $1
    `;
    const countResult = await pool.query(countSql, [ilikeValue]);
    const totalCount = parseInt(countResult.rows[0].total, 10);

    const offset = (page - 1) * pageSize;
    const selectSql = `
      SELECT
        id,
        owner_id AS "ownerId",
        data->>'brand' AS brand,
        data->>'name' AS name,
        data->>'description' AS description,
        data->'imageUrls' AS "imageUrls"
      FROM listing
      WHERE
        (data->>'brand') ILIKE $1
        OR (data->>'name') ILIKE $1
        OR (data->>'description') ILIKE $1
      LIMIT $2
      OFFSET $3
    `;

    const { rows } = await pool.query(selectSql, [ilikeValue, pageSize, offset]);

    const listings = rows.map((r: any) => ({
      ...r,
      imageUrls: r.imageUrls || [],
    }));

    return { listings, totalCount };
  }

  // In src/listing/graphql/service.ts, add:
  public async updateListingImages(id: UUID, imageUrls: string[]): Promise<boolean> {
    const updateSql = `
      UPDATE listing
      SET data = jsonb_set(
        data,
        '{imageUrls}',
        $2::jsonb,
        true
      )
      WHERE id = $1
    `;
    await pool.query(updateSql, [id, JSON.stringify(imageUrls)]);
    return true;
  }

}

================
File: Backend/src/message/graphql/resolver.ts
================
// src/message/graphql/resolver.ts

import { Authorized, Query, Resolver, Ctx, Mutation, Arg } from "type-graphql";
import { Request } from "express";
import { MessageService } from "./service";
import { Message, NewMessage } from "./schema";
import { UUID } from "../../common/types";
import { Service } from "typedi";

@Service()
@Resolver()
export class MessageResolver {
  constructor(private readonly messageService: MessageService) {}

  @Authorized()
  @Query(() => Message)
  async message(
    @Ctx() _req: Request,
    @Arg("input") id: UUID
  ): Promise<Message> {
    return this.messageService.getMessage(id);
  }

  @Authorized()
  @Query(() => [Message])
  async messagesByItemOwner(
    @Ctx() _req: Request,
    @Arg("input") itemOwnerId: UUID
  ): Promise<Message[]> {
    return this.messageService.getMessagesByItemOwner(itemOwnerId);
  }

  @Authorized()
  @Query(() => [Message])
  async messagesBySender(
    @Ctx() _req: Request,
    @Arg("input") senderId: UUID
  ): Promise<Message[]> {
    return this.messageService.getMessagesBySender(senderId);
  }

  @Authorized()
  @Mutation(() => Message)
  async createMessage(
    @Arg("input") messageInfo: NewMessage,
    @Ctx() _req: Request
  ): Promise<Message> {
    return this.messageService.createMessage(messageInfo);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteMessage(
    @Arg("input") messageId: UUID,
    @Ctx() _req: Request
  ): Promise<boolean> {
    return this.messageService.deleteMessage(messageId);
  }
}

================
File: Backend/src/message/graphql/schema.ts
================
// src/message/graphql/schema.ts

import { Field, InputType, ObjectType } from "type-graphql";
import { MinLength } from "class-validator";
import { UUID } from "../../common/types";

@ObjectType()
export class Message {
  @Field()
  id!: UUID;

  @Field()
  itemOwnerId!: UUID;

  @Field()
  senderId!: UUID;

  @Field()
  @MinLength(1)
  content!: string;
}

@InputType()
export class NewMessage {
  @Field()
  itemOwnerId!: UUID;

  @Field()
  senderId!: UUID;

  @Field()
  @MinLength(1)
  content!: string;
}

================
File: Backend/src/message/graphql/service.ts
================
// src/message/graphql/service.ts

import { Service } from "typedi";
import { pool } from "../../../db";
import { NewMessage, Message } from "./schema";
import { UUID } from "../../common/types";

@Service()
export class MessageService {
  public async getMessage(id: UUID): Promise<Message> {
    const select = `
      SELECT id, 
             item_owner_id as "itemOwnerId", 
             sender_id as "senderId", 
             data->>'content' as content
      FROM message 
      WHERE id = $1
    `;
    const { rows } = await pool.query(select, [id]);
    if (rows.length === 0) {
      throw new Error("Message not found.");
    }
    return rows[0];
  }

  public async getMessagesByItemOwner(itemOwnerId: UUID): Promise<Message[]> {
    const select = `
      SELECT id, 
             item_owner_id as "itemOwnerId", 
             sender_id as "senderId", 
             data->>'content' as content
      FROM message 
      WHERE item_owner_id = $1
    `;
    const { rows } = await pool.query(select, [itemOwnerId]);
    return rows;
  }

  public async getMessagesBySender(senderId: UUID): Promise<Message[]> {
    const select = `
      SELECT id, 
             item_owner_id as "itemOwnerId", 
             sender_id as "senderId", 
             data->>'content' as content
      FROM message 
      WHERE sender_id = $1
    `;
    const { rows } = await pool.query(select, [senderId]);
    return rows;
  }

  public async createMessage(info: NewMessage): Promise<Message> {
    const insert = `
      INSERT INTO message(item_owner_id, sender_id, data)
      VALUES ($1::uuid, $2::uuid, jsonb_build_object('content', $3::text))
      RETURNING id;
    `;
    const { rows } = await pool.query(insert, [
      info.itemOwnerId,
      info.senderId,
      info.content,
    ]);
    return {
      id: rows[0].id,
      itemOwnerId: info.itemOwnerId,
      senderId: info.senderId,
      content: info.content,
    };
  }

  public async deleteMessage(id: UUID): Promise<boolean> {
    const del = `DELETE FROM message WHERE id = $1`;
    await pool.query(del, [id]);
    return true;
  }
}

================
File: Backend/src/orders/graphql/resolver.ts
================
// src/orders/graphql/resolver.ts

import { Authorized, Resolver, Query, Mutation, Arg } from "type-graphql";
import { OrderService } from "./service";
import { Order, NewOrder, UUID, ShippingStatus } from "./schema";

@Resolver()
export class OrderResolver {
  private readonly orderService = new OrderService();

  @Authorized()
  @Query(() => Order)
  async order(@Arg("id") id: UUID): Promise<Order> {
    return this.orderService.getOrder(id);
  }

  @Authorized()
  @Query(() => [Order])
  async allOrders(): Promise<Order[]> {
    return this.orderService.getAllOrders();
  }

  @Authorized()
  @Mutation(() => Order)
  async createOrder(@Arg("input") input: NewOrder): Promise<Order> {
    return this.orderService.createOrder(input);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteOrder(@Arg("id") id: UUID): Promise<boolean> {
    return this.orderService.deleteOrder(id);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async updateOrderStatus(
    @Arg("id") id: UUID,
    @Arg("status", () => ShippingStatus) status: ShippingStatus
  ): Promise<boolean> {
    return this.orderService.updateShippingStatus(id, status);
  }
}

================
File: Backend/src/orders/graphql/schema.ts
================
//Backend/src/orders/graphql/schema.ts
import { Field, InputType, ObjectType, registerEnumType } from "type-graphql";
import { MinLength } from "class-validator";

/**
 * From your listing schema example:
 * @pattern [0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}
 * @format uuid
 */
export type UUID = string;

/**
 * Example shipping statuses. Feel free to add or change these.
 */
export enum ShippingStatus {
  PENDING = "PENDING",
  SHIPPED = "SHIPPED",
  DELIVERED = "DELIVERED",
  CANCELLED = "CANCELLED",
}

/**
 * Let TypeGraphQL know about our enum so it can generate correct schema types.
 */
registerEnumType(ShippingStatus, {
  name: "ShippingStatus",
});

@ObjectType()
export class Order {
  @Field()
  id!: UUID;

  // The account who placed the order
  @Field()
  buyerId!: UUID;

  // The account fulfilling the order (e.g. vendor or seller)
  @Field()
  sellerId!: UUID;

  @Field()
  itemId!: UUID;

  // Current shipping status of the order
  @Field(() => ShippingStatus)
  shippingStatus!: ShippingStatus;

  // Optionally store extra info
  // e.g., items, addresses, timestamps, etc.
  @Field({ nullable: true })
  data?: string;
}

@InputType()
export class NewOrder {
  @Field()
  buyerId!: UUID;

  @Field()
  sellerId!: UUID;

  @Field()
  itemId!: UUID; // ensure you capture itemId if needed

  @Field(() => ShippingStatus, { nullable: true })
  shippingStatus?: ShippingStatus;

  @Field({ nullable: true })
  @MinLength(1)
  data?: string;
}

================
File: Backend/src/orders/graphql/service.ts
================
//Backend/src/orders/graphql/service.ts
import { pool } from '../../../db';
import { NewOrder, Order, ShippingStatus, UUID } from './schema';

export class OrderService {
  /**
   * Fetch a single order by id.
   */
  public async getOrder(id: UUID): Promise<Order> {
    const select = `
      SELECT
        id,
        buyer_id,
        seller_id,
        item_id,
        shipping_status,
        data
      FROM orders
      WHERE id = $1
    `;
    const query = {
      text: select,
      values: [id],
    };
    const { rows } = await pool.query(query);

    if (rows.length === 0) {
      throw new Error('Order with given ID does not exist.');
    }

    // Convert row to Order object
    const row = rows[0];
    return {
      id: row.id,
      buyerId: row.buyer_id,
      sellerId: row.seller_id,
      itemId: row.item_id,
      shippingStatus: row.shipping_status as ShippingStatus,
      data: row.data || undefined,
    };
  }

  /**
   * Fetch all orders in the system (or optionally filter).
   */
  public async getAllOrders(): Promise<Order[]> {
    const select = `
      SELECT
        id,
        buyer_id,
        seller_id,
        item_id,
        shipping_status,
        data
      FROM orders
    `;
    const { rows } = await pool.query(select);

    return rows.map((row) => ({
      id: row.id,
      buyerId: row.buyer_id,
      sellerId: row.seller_id,
      itemId: row.item_id,
      shippingStatus: row.shipping_status as ShippingStatus,
      data: row.data || undefined,
    }));
  }

  /**
   * Create a new order in the DB.
   * shippingStatus defaults to 'PENDING' if not provided.
   */
  public async createOrder(info: NewOrder): Promise<Order> {
    const status = info.shippingStatus || ShippingStatus.PENDING;
    
    const insert = `
      INSERT INTO orders (buyer_id, seller_id, shipping_status, item_id, data)
      VALUES ($1::uuid, $2::uuid, $3::text, $4::uuid, $5::jsonb)
      RETURNING id
    `;
    const query = {
      text: insert,
      values: [
        info.buyerId,
        info.sellerId,
        status,
        info.itemId, // <--- pass the itemId now
        info.data ? JSON.stringify(info.data) : null,
      ],
    };
    
    const { rows } = await pool.query(query);
    const id = rows[0].id as UUID;
  
    return {
      id,
      buyerId: info.buyerId,
      sellerId: info.sellerId,
      itemId: info.itemId,
      shippingStatus: status,
      data: info.data,
    };
  }

  /**
   * Delete an order by id.
   * Returns true if deleted successfully, false if not found (optional).
   */
  public async deleteOrder(id: UUID): Promise<boolean> {
    const del = `
      DELETE FROM orders
      WHERE id = $1
    `;
    const query = {
      text: del,
      values: [id],
    };

    const result = await pool.query(query);
    // result.rowCount === 1 if a row was deleted
    return result.rowCount === 1;
  }

  /**
   * Update the shipping status for a given order.
   */
  public async updateShippingStatus(
    id: UUID,
    newStatus: ShippingStatus
  ): Promise<boolean> {
    const update = `
      UPDATE orders
      SET shipping_status = $2
      WHERE id = $1
    `;
    const query = {
      text: update,
      values: [id, newStatus],
    };

    const result = await pool.query(query);
    return result.rowCount === 1; // true if an order was updated
  }
}

================
File: Backend/src/s3/graphql/resolver.ts
================
// src/s3/graphql/resolver.ts
import { Service } from "typedi";
import { Resolver, Mutation, Arg } from "type-graphql";
import { S3UploadUrl } from "./schema";
import { getPresignedUploadUrl } from "./service";

@Service()
@Resolver()
export class S3Resolver {
  /**
   * Generate a pre-signed URL for uploading an image.
   * @param fileName - original filename (used as a base)
   * @param contentType - the MIME type of the file (e.g. image/jpeg)
   * @param folder - a folder string to separate profile images and listing images (e.g. "profile" or "listing")
   */
  @Mutation(() => S3UploadUrl)
  async generateUploadUrl(
    @Arg("fileName") fileName: string,
    @Arg("contentType") contentType: string,
    @Arg("folder") folder: string
  ): Promise<S3UploadUrl> {
    // Generate a unique key – here we prefix the filename with folder and a timestamp.
    const key = `${folder}/${Date.now()}_${fileName}`;
    console.log("[S3Resolver] Request received to generate upload URL for key:", key, "with content type:", contentType);

    try {
      const preSignedUrl = await getPresignedUploadUrl(key, contentType);
      const fileUrl = `https://${process.env.AWS_S3_BUCKET}.s3.${process.env.AWS_REGION}.amazonaws.com/${key}`;
      console.log("[S3Resolver] Pre-signed URL generated successfully:", preSignedUrl);
      console.log("[S3Resolver] File URL will be:", fileUrl);
      return { preSignedUrl, fileUrl };
    } catch (error) {
      console.error("[S3Resolver] Error generating upload URL:", error);
      throw error;
    }
  }
}

================
File: Backend/src/s3/graphql/schema.ts
================
// Backend/src/s3/graphql/schema.ts
import { ObjectType, Field, InputType } from "type-graphql";

@ObjectType()
export class S3UploadUrl {
  @Field()
  preSignedUrl!: string;

  @Field()
  fileUrl!: string;
}

================
File: Backend/src/s3/graphql/service.ts
================
// src/s3/graphql/s3service.ts
import AWS from 'aws-sdk';

AWS.config.update({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
  region: process.env.AWS_REGION!,
});

const s3 = new AWS.S3();

export async function getPresignedUploadUrl(key: string, contentType: string, expiresIn = 60): Promise<string> {
  const params = {
    Bucket: process.env.AWS_S3_BUCKET!,
    Key: key,
    Expires: expiresIn,
    ContentType: contentType,
    ACL: 'public-read', // so the image is publicly available
  };

  console.log("[s3service] Generating pre-signed URL with params:", params);

  try {
    const url = await s3.getSignedUrlPromise('putObject', params);
    console.log("[s3service] Pre-signed URL generated successfully:", url);
    return url;
  } catch (error) {
    console.error("[s3service] Error generating pre-signed URL:", error);
    throw error;
  }
}

================
File: Backend/tests/domains/account/account.test.ts
================
// tests/domains/account/account.test.ts

import * as http from "http";
import supertest from "supertest";
import { createApp } from "../../../index";
import { resetGlobal, shutdown } from "../common/db/reset";

let server: http.Server;
let token = "";

beforeAll(async () => {
  // Reset the test database using global fixtures.
  await resetGlobal();
  const app = await createApp();
  server = http.createServer(app);
  server.listen(0);

  // Login (using the mutation) to get a token for protected operations.
  const loginResponse = await supertest(server)
    .post("/graphql")
    .send({
      query: `
        mutation login {
          login(input: { email: "test@example.com", password: "password" }) {
            accessToken
          }
        }
      `
    });
  if (!loginResponse.body.data || !loginResponse.body.data.login) {
    throw new Error(`Login failed. Response: ${JSON.stringify(loginResponse.body)}`);
  }
  token = loginResponse.body.data.login.accessToken;
}, 10000);

afterAll((done) => {
  // Shutdown the DB pool and then close the HTTP server.
  shutdown(() => {
    server.close(done);
  });
});

let id = "";

describe("Account Resolver Tests", () => {
  it("Can get member by ID", async () => {
    // This fixed ID is seeded via the global fixtures.
    const seededId = "00000000-0000-0000-0000-000000000001";
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          account(input: "${seededId}") {
            id
            name { first last }
            email
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.account.email).toBe("sammy@slugmart.com");
        expect(res.body.data.account.name.first).toBe("Sammy");
        expect(res.body.data.account.name.last).toBe("Slug");
      });
  });

  it("Cant get member by non-existent ID", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          account(input: "10000000-0000-0000-0000-000000000000") {
            id
            name { first last }
            email
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  it("Can get member by email", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          accountByEmail(input: "sammy@slugmart.com") {
            id
            name { first last }
            email
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.accountByEmail.email).toBe("sammy@slugmart.com");
        expect(res.body.data.accountByEmail.name.first).toBe("Sammy");
        expect(res.body.data.accountByEmail.name.last).toBe("Slug");
      });
  });

  it("Cant get member by non-existent email", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          accountByEmail(input: "noEmail@slugmart.com") {
            id
            name { first last }
            email
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  // "makeAccount" is a public operation.
  it("Can make account", async () => {
    await supertest(server)
      .post("/graphql")
      .send({
        query: `mutation m {
          makeAccount(input: {
            email: "SlugAdmin@mart.com",
            password: "abc",
            firstName: "Slug",
            lastName: "min",
            username: "slugadmin",
            roles: ["Admin", "Shopper"]
          }) {
            id
            email
            name { first last }
            roles
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.makeAccount.email).toBe("slugadmin@mart.com");
        expect(res.body.data.makeAccount.name.first).toBe("Slug");
        expect(res.body.data.makeAccount.name.last).toBe("min");
        id = res.body.data.makeAccount.id;
        expect(id).toBeTruthy();
      });
  });

  it("Cant make account with same email address", async () => {
    await supertest(server)
      .post("/graphql")
      .send({
        query: `mutation m {
          makeAccount(input: {
            email: "SlugAdmin@mart.com",
            password: "abc",
            firstName: "Slug",
            lastName: "min",
            username: "slugadmin",
            roles: ["Admin", "Shopper"]
          }) {
            id
            email
            name { first last }
            roles
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  it("Can delete account", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation delete {
          deleteAccount(input: "${id}")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.deleteAccount).toBe(true);
      });
  });

  it("Member should no longer exist", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          account(input: "${id}") {
            id
            name { first last }
            email
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  // Re-create the account for further suspend/resume tests.
  it("Make another account", async () => {
    await supertest(server)
      .post("/graphql")
      .send({
        query: `mutation m {
          makeAccount(input: {
            email: "SlugAdmin@mart.com",
            password: "abc",
            firstName: "Slug",
            lastName: "min",
            username: "slugadmin",
            roles: ["Admin", "Shopper"]
          }) {
            id
            email
            name { first last }
            roles
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.makeAccount.email).toBe("slugadmin@mart.com");
        expect(res.body.data.makeAccount.name.first).toBe("Slug");
        expect(res.body.data.makeAccount.name.last).toBe("min");
        id = res.body.data.makeAccount.id;
        expect(id).toBeTruthy();
      });
  });

  it("Can delete account by email", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation delete {
          deleteAccountByEmail(input: "SlugAdmin@mart.com")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.deleteAccountByEmail).toBe(true);
      });
  });

  it("Member should no longer exist (by email)", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          accountByEmail(input: "slugadmin@mart.com") {
            id
            name { first last }
            email
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  // Re-create the account again for suspend/resume tests.
  it("Make another account (again)", async () => {
    await supertest(server)
      .post("/graphql")
      .send({
        query: `mutation m {
          makeAccount(input: {
            email: "SlugAdmin@mart.com",
            password: "abc",
            firstName: "Slug",
            lastName: "min",
            username: "slugadmin",
            roles: ["Admin", "Shopper"]
          }) {
            id
            email
            name { first last }
            roles
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.makeAccount.email).toBe("slugadmin@mart.com");
        expect(res.body.data.makeAccount.name.first).toBe("Slug");
        expect(res.body.data.makeAccount.name.last).toBe("min");
        id = res.body.data.makeAccount.id;
        expect(id).toBeTruthy();
      });
  });

  it("Can suspend account by ID", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation suspend {
          suspendAccount(input: "${id}")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.suspendAccount).toBe(true);
      });
  });

  it("Account should be suspended", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          account(input: "${id}") {
            id
            name { first last }
            email
            restricted
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.account.restricted).toBe(true);
      });
  });

  it("Can resume account by ID", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation resume {
          resumeAccount(input: "${id}")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.resumeAccount).toBe(true);
      });
  });

  it("Account should not be suspended", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          account(input: "${id}") {
            id
            name { first last }
            email
            restricted
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.account.restricted).toBe(false);
      });
  });

  it("Can suspend account by email", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation suspend {
          suspendAccountByEmail(input: "slugadmin@mart.com")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.suspendAccountByEmail).toBe(true);
      });
  });

  it("Account should be suspended (by email)", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          accountByEmail(input: "slugadmin@mart.com") {
            id
            name { first last }
            email
            restricted
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.accountByEmail.restricted).toBe(true);
      });
  });

  it("Can resume account by email", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation resume {
          resumeAccountByEmail(input: "slugadmin@mart.com")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.resumeAccountByEmail).toBe(true);
      });
  });

  it("Account should not be suspended (by email)", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          accountByEmail(input: "slugadmin@mart.com") {
            id
            name { first last }
            email
            restricted
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.accountByEmail.restricted).toBe(false);
      });
  });

  it("Can get all accounts", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query g {
          allAccounts {
            id
            email
            name { first last }
            roles
            restricted
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(Array.isArray(res.body.data.allAccounts)).toBe(true);
        expect(res.body.data.allAccounts.length).toBeGreaterThan(0);
      });
  });
});

================
File: Backend/tests/domains/auth/check.test.ts
================
// tests/domains/auth/check.test.ts

import { gql, request } from "graphql-request";
import * as http from "http";
import { AddressInfo } from "net";
import { createApp } from "../../../index";
import { resetGlobal, shutdown } from "../common/db/reset";

let server: http.Server;
let endpoint: string;

beforeAll(async () => {
  await resetGlobal();
  const app = await createApp();
  server = http.createServer(app);
  await new Promise<void>((resolve) => {
    server.listen(0, () => {
      const address = server.address() as AddressInfo;
      endpoint = `http://localhost:${address.port}/graphql`;
      resolve();
    });
  });
}, 10000);

afterAll((done) => {
  shutdown(() => server.close(done));
});

interface LoginForCheckResponse {
  login: {
    id: string;
    accessToken: string;
  };
}

interface CheckResponse {
  check: {
    id: string;
  };
}

describe("AuthService check", () => {
  let accessToken: string;
  beforeAll(async () => {
    const loginQuery = gql`
      mutation Login($input: Credentials!) {
        login(input: $input) {
          id
          accessToken
        }
      }
    `;
    const variables = {
      input: { email: "test@example.com", password: "password" },
    };
    const response = await request<LoginForCheckResponse>(
      endpoint,
      loginQuery,
      variables
    );
    accessToken = response.login.accessToken;
  });

  it("should return an account id with a valid token", async () => {
    const checkQuery = gql`
      query Check($input: String!) {
        check(input: $input) {
          id
        }
      }
    `;
    const checkVars = { input: accessToken };

    const checkResponse = await request<CheckResponse>(
      endpoint,
      checkQuery,
      checkVars,
      { authorization: `Bearer ${accessToken}` }
    );

    expect(checkResponse.check.id).toBeTruthy();
  });
});

================
File: Backend/tests/domains/auth/login.test.ts
================
// tests/domains/auth/login.test.ts

import { gql, request } from "graphql-request";
import * as http from "http";
import { AddressInfo } from "net";
import { createApp } from "../../../index";
import { resetGlobal, shutdown } from "../common/db/reset";

let server: http.Server;
let endpoint = "";

beforeAll(async () => {
  await resetGlobal();
  const app = await createApp();
  server = http.createServer(app);
  await new Promise<void>((resolve) => {
    server.listen(0, () => {
      const address = server.address() as AddressInfo;
      endpoint = `http://localhost:${address.port}/graphql`;
      resolve();
    });
  });
}, 10000);

afterAll((done) => {
  shutdown(() => server.close(done));
});

interface LoginResponse {
  login: {
    id: string;
    name: { first: string; last: string };
    accessToken: string;
  };
}

describe("AuthService login", () => {
  it("should login with valid credentials", async () => {
    const query = gql`
      mutation Login($input: Credentials!) {
        login(input: $input) {
          id
          name {
            first
            last
          }
          accessToken
        }
      }
    `;
    const variables = {
      input: { email: "test@example.com", password: "password" },
    };
    const response = await request<LoginResponse>(endpoint, query, variables);
    expect(response.login).toBeDefined();
    expect(response.login.id).toBeTruthy();
    expect(response.login.name.first).toBe("John");
    expect(response.login.name.last).toBe("Doe");
    expect(response.login.accessToken).toBeTruthy();
  });

  it("should return an error for invalid credentials", async () => {
    const query = gql`
      mutation Login($input: Credentials!) {
        login(input: $input) {
          id
          name {
            first
            last
          }
          accessToken
        }
      }
    `;
    const variables = {
      input: { email: "wrong@example.com", password: "wrongpass" },
    };
    // Expect the promise to be rejected with an error message containing "Invalid Credentials"
    await expect(request<LoginResponse>(endpoint, query, variables))
      .rejects.toThrow(/Invalid Credentials/);
  });
});

================
File: Backend/tests/domains/common/db/reset.ts
================
// tests/domains/common/db/reset.ts

import { pool } from "../../../../db";
import dotenv from "dotenv";
import * as fs from "fs";
import * as path from "path";

dotenv.config();

async function runSqlFile(filePath: string): Promise<void> {
  const content = fs.readFileSync(filePath, "utf8");
  await pool.query(content);
  console.log(`Executed SQL file: ${filePath}`);
}

/**
 * Resets the entire test database using the global fixtures.
 */
export async function resetGlobal(): Promise<void> {
  const fixturesPath = path.join(__dirname, "..", "..", "..", "fixtures");
  const schemaFile = path.join(fixturesPath, "schema.sql");
  const dataFile = path.join(fixturesPath, "data.sql");

  if (fs.existsSync(schemaFile)) {
    await runSqlFile(schemaFile);
  } else {
    throw new Error(`Global schema file not found at: ${schemaFile}`);
  }

  if (fs.existsSync(dataFile)) {
    await runSqlFile(dataFile);
  } else {
    throw new Error(`Global data file not found at: ${dataFile}`);
  }
}

/**
 * Shut down the pool entirely.
 */
export function shutdown(done: Function): void {
  pool.end(() => done());
}

================
File: Backend/tests/domains/listing/listing.test.ts
================
import * as http from "http";
import supertest from "supertest";
import { createApp } from "../../../index";
import { resetGlobal, shutdown } from "../common/db/reset";

let server: http.Server;
let token = "";

beforeAll(async () => {
  await resetGlobal();
  const app = await createApp();
  server = http.createServer(app);
  server.listen(0);

  // Login to obtain a valid token for protected operations
  const loginResponse = await supertest(server)
    .post("/graphql")
    .send({
      query: `
        query login {
          login(input: { email: "test@example.com", password: "password" }) {
            accessToken
          }
        }
      `
    });
  token = loginResponse.body.data.login.accessToken;
}, 10000);

afterAll((done) => {
  shutdown(() => server.close(done));
});

let createdListingId = "";

describe("Listing Resolver Tests", () => {
  it("Can get listing by ID", async () => {
    // Use a fixed seeded listing ID from the global fixtures
    const existingId = "00000000-0000-0000-0000-000000000010";
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          listing(id: "${existingId}") {
            id
            ownerId
            brand
            name
            description
            imageUrls
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.listing.id).toBe(existingId);
        expect(res.body.data.listing.brand).toBe("TestBrand");
        expect(res.body.data.listing.name).toBe("TestName");
        expect(res.body.data.listing.description).toBe("A test description");
        expect(Array.isArray(res.body.data.listing.imageUrls)).toBe(true);
      });
  });

  it("Cant get listing by non-existent ID", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          listing(id: "10000000-0000-0000-0000-000000000000") {
            id
            ownerId
            brand
            name
            description
            imageUrls
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  it("Can get all listings (paginated)", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `
          query getAllListings {
            allListings(page: 1, pageSize: 10) {
              listings {
                id
                ownerId
                brand
                name
                description
                imageUrls
              }
              totalCount
            }
          }
        `
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const data = res.body.data.allListings;
        expect(data).toBeDefined();
        expect(Array.isArray(data.listings)).toBe(true);
        expect(data.listings.length).toBeGreaterThan(0);
        expect(typeof data.totalCount).toBe("number");
        expect(data.totalCount).toBeGreaterThan(0);
      });
  });

  it("Can create a new listing", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation create {
          createListing(input: {
            ownerId: "00000000-0000-0000-0000-000000000001",
            brand: "NewBrand",
            name: "NewItem",
            description: "Brand new test item",
            imageUrls: ["http://example.com/image1.jpg", "http://example.com/image2.jpg"]
          }) {
            id
            ownerId
            brand
            name
            description
            imageUrls
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const listing = res.body.data.createListing;
        expect(listing.id).toBeDefined();
        expect(listing.ownerId).toBe("00000000-0000-0000-0000-000000000001");
        expect(listing.brand).toBe("NewBrand");
        expect(listing.name).toBe("NewItem");
        expect(listing.description).toBe("Brand new test item");
        expect(listing.imageUrls.length).toBe(2);
        createdListingId = listing.id;
      });
  });

  it("Can delete listing", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation delete {
          deleteListing(id: "${createdListingId}")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.deleteListing).toBe(true);
      });
  });

  it("Deleted listing should no longer exist", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          listing(id: "${createdListingId}") {
            id
            ownerId
            brand
            name
            description
            imageUrls
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  it("Can search for listings by partial brand", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `
          query search {
            searchListings(searchTerm: "test", page: 1, pageSize: 10) {
              listings {
                id
                brand
              }
              totalCount
            }
          }
        `
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const data = res.body.data.searchListings;
        expect(data).toBeDefined();
        expect(data.totalCount).toBeGreaterThan(0);
        expect(data.listings.length).toBeGreaterThan(0);
        const first = data.listings[0];
        expect(first.brand.toLowerCase()).toContain("test");
      });
  });

  it("Returns empty search results if no listing matches", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `
          query search {
            searchListings(searchTerm: "xyzzznotfound", page: 1, pageSize: 10) {
              listings {
                id
                brand
                name
              }
              totalCount
            }
          }
        `
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const data = res.body.data.searchListings;
        expect(data.totalCount).toBe(0);
        expect(data.listings.length).toBe(0);
      });
  });

  it("Can search with pagination", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `
          query search {
            searchListings(searchTerm: "test", page: 1, pageSize: 1) {
              listings {
                id
                brand
                name
              }
              totalCount
            }
          }
        `
      })
      .expect(200)
      .then(async (res) => {
        expect(res.body.errors).toBeUndefined();
        const data = res.body.data.searchListings;
        expect(data.totalCount).toBeGreaterThanOrEqual(1);
        expect(data.listings.length).toBeLessThanOrEqual(1);
        const secondPageRes = await supertest(server)
          .post("/graphql")
          .set("Authorization", `Bearer ${token}`)
          .send({
            query: `
              query search2 {
                searchListings(searchTerm: "test", page: 2, pageSize: 1) {
                  listings {
                    id
                    brand
                    name
                  }
                  totalCount
                }
              }
            `
          });
        expect(secondPageRes.body.errors).toBeUndefined();
        const secondData = secondPageRes.body.data.searchListings;
        if (data.totalCount > 1) {
          expect(secondData.listings.length).toBe(1);
        } else {
          expect(secondData.listings.length).toBe(0);
        }
      });
  });
});

================
File: Backend/tests/domains/message/message.test.ts
================
import * as http from "http";
import supertest from "supertest";
import { createApp } from "../../../index";
import { resetGlobal, shutdown } from "../common/db/reset";

let server: http.Server;
let token = "";

beforeAll(async () => {
  await resetGlobal();
  const app = await createApp();
  server = http.createServer(app);
  server.listen(0);

  // Login to obtain a valid token for protected operations
  const loginResponse = await supertest(server)
    .post("/graphql")
    .send({
      query: `
        query login {
          login(input: { email: "test@example.com", password: "password" }) {
            accessToken
          }
        }
      `
    });
  token = loginResponse.body.data.login.accessToken;
}, 10000);

afterAll((done) => {
  shutdown(() => server.close(done));
});

let createdMessageId = "";
const existingItemOwnerId = "00000000-0000-0000-0000-000000000010";
const existingSenderId = "00000000-0000-0000-0000-000000000002";

describe("Message Resolver Tests", () => {
  it("Can create a new message", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation create {
          createMessage(input: {
            itemOwnerId: "${existingItemOwnerId}",
            senderId: "${existingSenderId}",
            content: "Hello, is this item still available?"
          }) {
            id
            itemOwnerId
            senderId
            content
          }
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeUndefined();
    const msg = res.body.data.createMessage;
    expect(msg.id).toBeDefined();
    expect(msg.itemOwnerId).toBe(existingItemOwnerId);
    expect(msg.senderId).toBe(existingSenderId);
    expect(msg.content).toBe("Hello, is this item still available?");
    createdMessageId = msg.id;
  });

  it("Can get message by ID", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          message(input: "${createdMessageId}") {
            id
            itemOwnerId
            senderId
            content
          }
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeUndefined();
    const msg = res.body.data.message;
    expect(msg.id).toBe(createdMessageId);
    expect(msg.itemOwnerId).toBe(existingItemOwnerId);
    expect(msg.senderId).toBe(existingSenderId);
    expect(msg.content).toBe("Hello, is this item still available?");
  });

  it("Can get messages by itemOwnerId", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          messagesByItemOwner(input: "${existingItemOwnerId}") {
            id
            itemOwnerId
            senderId
            content
          }
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeUndefined();
    const msgs = res.body.data.messagesByItemOwner;
    expect(Array.isArray(msgs)).toBe(true);
    expect(msgs.length).toBeGreaterThan(0);
    expect(msgs.some((m: any) => m.id === createdMessageId)).toBe(true);
  });

  it("Can get messages by senderId", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          messagesBySender(input: "${existingSenderId}") {
            id
            itemOwnerId
            senderId
            content
          }
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeUndefined();
    const msgs = res.body.data.messagesBySender;
    expect(Array.isArray(msgs)).toBe(true);
    expect(msgs.length).toBeGreaterThan(0);
    expect(msgs.some((m: any) => m.id === createdMessageId)).toBe(true);
  });

  it("Cant get message by non-existent ID", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          message(input: "10000000-0000-0000-0000-000000000000") {
            id
            itemOwnerId
            senderId
            content
          }
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeDefined();
    expect(res.body.errors.length).toBeGreaterThan(0);
  });

  it("Can delete message", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation del {
          deleteMessage(input: "${createdMessageId}")
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeUndefined();
    expect(res.body.data.deleteMessage).toBe(true);
  });

  it("Deleted message should no longer exist", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          message(input: "${createdMessageId}") {
            id
            itemOwnerId
            senderId
            content
          }
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeDefined();
    expect(res.body.errors.length).toBeGreaterThan(0);
  });
});

================
File: Backend/tests/domains/orders/orders.test.ts
================
import * as http from "http";
import supertest from "supertest";
import { createApp } from "../../../index";
import { resetGlobal, shutdown } from "../common/db/reset";

let orderId = "";
let server: http.Server;
let token = "";

beforeAll(async () => {
  await resetGlobal();
  const app = await createApp();
  server = http.createServer(app);
  server.listen(0);

  // Login to obtain a valid token for protected operations
  const loginResponse = await supertest(server)
    .post("/graphql")
    .send({
      query: `
        query login {
          login(input: { email: "test@example.com", password: "password" }) {
            accessToken
          }
        }
      `
    });
  token = loginResponse.body.data.login.accessToken;
}, 10000);

afterAll((done) => {
  shutdown(() => server.close(done));
});

describe("Order Resolver Tests", () => {
  it("Can create a new order", async () => {
    const buyerId = "00000000-0000-0000-0000-000000000002"; // from global seed
    const sellerId = "00000000-0000-0000-0000-000000000001"; // from global seed
    const itemId = "00000000-0000-0000-0000-000000000010"; // seeded listing
    const mutation = `
      mutation create {
        createOrder(input: {
          buyerId: "${buyerId}",
          sellerId: "${sellerId}",
          itemId: "${itemId}",
          shippingStatus: PENDING,
          data: "LineItems or JSON data"
        }) {
          id
          buyerId
          sellerId
          shippingStatus
          data
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query: mutation })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const created = res.body.data.createOrder;
        expect(created).toBeDefined();
        expect(created.buyerId).toBe(buyerId);
        expect(created.sellerId).toBe(sellerId);
        expect(created.shippingStatus).toBe("PENDING");
        expect(created.data).toBe("LineItems or JSON data");
        orderId = created.id;
      });
  });

  it("Can fetch order by id", async () => {
    const query = `
      query get {
        order(id: "${orderId}") {
          id
          buyerId
          sellerId
          shippingStatus
          data
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const fetched = res.body.data.order;
        expect(fetched).toBeDefined();
        expect(fetched.id).toBe(orderId);
      });
  });

  it("Can update shipping status", async () => {
    const mutation = `
      mutation update {
        updateOrderStatus(id: "${orderId}", status: SHIPPED)
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query: mutation })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.updateOrderStatus).toBe(true);
      });
    const checkQuery = `
      query check {
        order(id: "${orderId}") {
          id
          shippingStatus
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query: checkQuery })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.order.shippingStatus).toBe("SHIPPED");
      });
  });

  it("Can fetch all orders", async () => {
    const query = `
      query getAll {
        allOrders {
          id
          buyerId
          sellerId
          shippingStatus
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const orders = res.body.data.allOrders;
        expect(Array.isArray(orders)).toBe(true);
        expect(orders.length).toBeGreaterThan(0);
        const found = orders.find((o: any) => o.id === orderId);
        expect(found).toBeDefined();
      });
  });

  it("Can delete an order", async () => {
    const mutation = `
      mutation remove {
        deleteOrder(id: "${orderId}")
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query: mutation })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.deleteOrder).toBe(true);
      });
    const checkQuery = `
      query check {
        order(id: "${orderId}") {
          id
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query: checkQuery })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });
});

================
File: Backend/tests/fixtures/data.sql
================
-- tests/fixtures/data.sql
-- Global seed data for tests

-- Seed accounts with fixed IDs
INSERT INTO account (id, email, data, restricted)
VALUES
  (
    '00000000-0000-0000-0000-000000000001',
    'sammy@slugmart.com',
    jsonb_build_object(
      'password', crypt('sammyslug', 'hello'),
      'name', jsonb_build_object('first', 'Sammy', 'last', 'Slug'),
      'roles', jsonb_build_array('Shopper','Vendor','Admin'),
      'profile', jsonb_build_object('username', 'sammyslug', 'bio', 'I love shopping.')
    ),
    false
  ),
  (
    '00000000-0000-0000-0000-000000000002',
    'test@example.com',
    jsonb_build_object(
      'password', crypt('password', 'hello'),
      'name', jsonb_build_object('first', 'John', 'last', 'Doe'),
      'roles', jsonb_build_array('admin'),
      'profile', jsonb_build_object('username', 'johndoe', 'bio', 'Administrator account.')
    ),
    false
  );

-- Seed listings (using fixed IDs)
INSERT INTO listing (id, owner_id, data)
VALUES
  (
    '00000000-0000-0000-0000-000000000010',
    '00000000-0000-0000-0000-000000000001',
    jsonb_build_object(
      'brand', 'TestBrand',
      'name', 'TestName',
      'description', 'A test description',
      'imageUrls', ARRAY['http://example.com/image.jpg']
    )
  )
ON CONFLICT (id) DO NOTHING;

INSERT INTO listing (id, owner_id, data)
VALUES
  (
    '00000000-0000-0000-0000-000000000011',
    '00000000-0000-0000-0000-000000000001',
    jsonb_build_object(
      'brand', 'TestBrand2',
      'name', 'AnotherItem',
      'description', 'Another test description',
      'imageUrls', ARRAY['http://example.com/image2.jpg']
    )
  )
ON CONFLICT (id) DO NOTHING;

-- Seed a message
INSERT INTO message (id, item_owner_id, sender_id, data)
VALUES (
  '00000000-0000-0000-0000-000000000100',
  '00000000-0000-0000-0000-000000000010',
  '00000000-0000-0000-0000-000000000002',
  jsonb_build_object('content', 'Initial test message')
)
ON CONFLICT (id) DO NOTHING;

-- Seed orders
INSERT INTO orders (id, buyer_id, seller_id, shipping_status, item_id, data)
VALUES
  (
    '11111111-1111-1111-1111-111111111111',
    '00000000-0000-0000-0000-000000000002',
    '00000000-0000-0000-0000-000000000001',
    'PENDING',
    '00000000-0000-0000-0000-000000000010',
    jsonb_build_object('notes', 'Sample seeded order #1')
  )
ON CONFLICT (id) DO NOTHING;

INSERT INTO orders (id, buyer_id, seller_id, shipping_status, item_id, data)
VALUES
  (
    '22222222-2222-2222-2222-222222222222',
    '00000000-0000-0000-0000-000000000002',
    '00000000-0000-0000-0000-000000000001',
    'SHIPPED',
    '00000000-0000-0000-0000-000000000011',
    jsonb_build_object('notes', 'Sample seeded order #2')
  )
ON CONFLICT (id) DO NOTHING;

================
File: Backend/tests/fixtures/schema.sql
================
-- tests/fixtures/schema.sql
-- Production schema for all tables

CREATE EXTENSION IF NOT EXISTS pgcrypto;

DROP TABLE IF EXISTS orders CASCADE;
DROP TABLE IF EXISTS message CASCADE;
DROP TABLE IF EXISTS listing CASCADE;
DROP TABLE IF EXISTS account CASCADE;

-- Account table
CREATE TABLE account (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text UNIQUE NOT NULL,
  data jsonb NOT NULL,
  restricted boolean NOT NULL DEFAULT false
);

-- Listing table
CREATE TABLE listing (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id uuid NOT NULL,
  data jsonb NOT NULL
);

-- Message table
CREATE TABLE message (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  item_owner_id uuid NOT NULL,
  sender_id uuid NOT NULL,
  data jsonb NOT NULL
);

-- Orders table
CREATE TABLE orders (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  buyer_id uuid NOT NULL,
  seller_id uuid NOT NULL,
  shipping_status text NOT NULL DEFAULT 'pending',
  item_id uuid NOT NULL,
  data jsonb,
  CONSTRAINT fk_order_buyer
    FOREIGN KEY (buyer_id)
    REFERENCES account (id)
    ON DELETE CASCADE,
  CONSTRAINT fk_order_seller
    FOREIGN KEY (seller_id)
    REFERENCES account (id)
    ON DELETE CASCADE,
  CONSTRAINT fk_order_item
    FOREIGN KEY (item_id)
    REFERENCES listing (id)
);

================
File: Backend/tests/dbTest.ts
================
// tests/dbTest.ts

import { Pool } from "pg";
import dotenv from "dotenv";
import * as fs from "fs";
import * as path from "path";

dotenv.config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL, // points to your test DB
});

export async function resetGlobal(): Promise<void> {
  const fixturesPath = path.join(__dirname, "fixtures");
  const schemaFile = path.join(fixturesPath, "schema.sql");
  const dataFile = path.join(fixturesPath, "data.sql");

  if (fs.existsSync(schemaFile)) {
    const schema = fs.readFileSync(schemaFile, "utf8");
    await pool.query(schema);
    console.log(`Executed global schema file: ${schemaFile}`);
  } else {
    throw new Error(`Global schema file not found at: ${schemaFile}`);
  }

  if (fs.existsSync(dataFile)) {
    const data = fs.readFileSync(dataFile, "utf8");
    await pool.query(data);
    console.log(`Executed global data file: ${dataFile}`);
  } else {
    throw new Error(`Global data file not found at: ${dataFile}`);
  }
}

export function shutdown(done: Function): void {
  pool.end(() => {
    done();
  });
}

================
File: Backend/babel.config.js
================
// microservices/auth/babel.config.js
module.exports = {
    presets: [
      ['@babel/preset-env', { targets: { node: 'current' } }], 
      '@babel/preset-typescript'
    ],
  };

================
File: Backend/db.ts
================
import { Pool } from 'pg';
import dotenv from 'dotenv';
dotenv.config();

console.log(process.env.DATABASE_URL);

export const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
  });

================
File: Backend/index.ts
================
// src/index.ts
import dotenv from "dotenv";
import express from "express";
import helmet from "helmet";
import { createHandler } from "graphql-http/lib/use/express";
import { Pool } from "pg";
import "reflect-metadata";
import { buildSchema, AuthChecker } from "type-graphql";
import * as jwt from "jsonwebtoken";
import { Container } from "typedi";

// Import AWS SDK (v2 in this example)
import AWS from "aws-sdk";

dotenv.config();

import { AccountResolver } from "./src/account/graphql/resolver";
import { AuthResolver } from "./src/auth/graphql/resolver";
import { ListingResolver } from "./src/listing/graphql/resolver";
import { MessageResolver } from "./src/message/graphql/resolver";
import { OrderResolver } from "./src/orders/graphql/resolver";
import { S3Resolver } from "./src/s3/graphql/resolver";

// Use a single database pool instance
export const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});


/**
 * Global auth checker for TypeGraphQL.
 * Public operations like login and makeAccount bypass authentication.
 */
const customAuthChecker: AuthChecker<any> = ({ context }, roles) => {
  if (context.req.body && typeof context.req.body.query === "string") {
    if (/(\blogin\b)|(\bmakeAccount\b)/i.test(context.req.body.query)) {
      return true;
    }
  }
  const authHeader = context.req.headers.authorization;
  if (!authHeader) {
    return false;
  }
  const token = authHeader.split(" ")[1];
  try {
    const decoded = jwt.verify(token, process.env.MASTER_SECRET as string) as { id: string };
    context.userId = decoded.id;
    return true;
  } catch (err) {
    return false;
  }
};

async function createSchema() {
  return await buildSchema({
    resolvers: [
      AuthResolver,
      AccountResolver,
      ListingResolver,
      MessageResolver,
      OrderResolver,
      S3Resolver,
    ],
    authChecker: customAuthChecker,
    container: Container,
  });
}

/**
 * Ping the S3 bucket by calling headBucket.
 */
async function pingS3(): Promise<void> {
  const s3 = new AWS.S3({
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
    region: process.env.AWS_REGION!,
  });
  try {
    // headBucket checks that the bucket exists and that the credentials are valid.
    await s3.headBucket({ Bucket: process.env.AWS_S3_BUCKET! }).promise();
    console.log("Successfully connected to S3 bucket:", process.env.AWS_S3_BUCKET);
  } catch (error) {
    console.error("Error connecting to S3 bucket:", error);
    throw error;
  }
}

export async function createApp() {
  // Test database connection
  const client = await pool.connect();
  const res = await client.query("SELECT NOW()");
  client.release();
  console.log("Connected to database, current time:", res.rows[0].now);

  // Ping S3 to ensure connectivity before starting
  await pingS3();

  // Build the GraphQL schema
  const schema = await createSchema();

  const app = express();

  app.use(helmet());
  app.use(express.json());

  // Mount the GraphQL endpoint (auth is handled via TypeGraphQL)
  app.all(
    "/graphql",
    createHandler({
      schema,
      context: (req) => ({ req }),
    })
  );

  return app;
}

if (require.main === module) {
  createApp()
    .then((app) => {
      app.listen(4000, () => {
        console.log("Running a GraphQL API server at http://localhost:4000/graphql");
      });
    })
    .catch((err) => {
      console.error("Failed to start server", err);
    });
}

================
File: Backend/jest.config.js
================
// microservices/auth/jest.config.js
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    rootDir: './',
    //testMatch: ['<rootDir>/src/test/*.test.ts'],
    moduleFileExtensions: ['ts', 'js'],
    transform: {
        '^.+\\.(ts|tsx)$': [
            'ts-jest',
            { 
                tsconfig: 'tsconfig.json'
            }
        ],
        // This line allows Babel to transform ESM in node_modules
        '^.+\\.(js|mjs)$': 'babel-jest',
    },
    testPathIgnorePatterns: [
        "/node_modules/",
        "/dist/"
      ],
    transformIgnorePatterns: [
        // Override default to allow graphql-request to be transformed
        'node_modules/(?!graphql-request)'
    ],

};

================
File: Backend/package.json
================
{
  "name": "vintain-backend",
  "version": "1.0.0",
  "description": "",
  "main": "dist/index.js",
  "scripts": {
    "dev": "ts-node src/index.ts",
    "build": "tsc",
    "start": "tsc && node dist/index.js",
    "test": "npm run test:auth && npm run test:account && npm run test:listing && npm run test:message && npm run test:orders",
    "test:auth": "jest --config jest.config.js --testPathPattern='tests/domains/auth/' --runInBand",
    "test:account": "jest --config jest.config.js --testPathPattern='tests/domains/account/' --runInBand",
    "test:listing": "jest --config jest.config.js --testPathPattern='tests/domains/listing/' --runInBand",
    "test:message": "jest --config jest.config.js --testPathPattern='tests/domains/message/' --runInBand",
    "test:orders": "jest --config jest.config.js --testPathPattern='tests/domains/orders/' --runInBand"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@aws-sdk/client-s3": "^3.741.0",
    "@aws-sdk/s3-request-presigner": "^3.741.0",
    "aws-sdk": "^2.1692.0",
    "class-validator": "^0.14.1",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "graphql": "^16.10.0",
    "graphql-http": "^1.22.3",
    "graphql-request": "^7.1.2",
    "helmet": "^8.0.0",
    "http": "^0.0.1-security",
    "jsonwebtoken": "^9.0.2",
    "pg": "^8.13.1",
    "reflect-metadata": "^0.2.2",
    "supertest": "^7.0.0",
    "type-graphql": "^2.0.0-rc.2",
    "typedi": "^0.10.0"
  },
  "devDependencies": {
    "@babel/preset-env": "^7.26.0",
    "@babel/preset-typescript": "^7.26.0",
    "@types/express": "^5.0.0",
    "@types/graphql": "^14.5.0",
    "@types/jest": "^29.5.14",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/node": "^22.10.2",
    "@types/pg": "^8.11.10",
    "@types/supertest": "^6.0.2",
    "jest": "^29.7.0",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.7.2"
  }
}

================
File: Backend/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-06T00:36:18.366Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  account/
    graphql/
      resolver.ts
      schema.ts
      service.ts
  auth/
    graphql/
      resolver.ts
      schema.ts
      service.ts
  common/
    decorators.ts
    s3service.ts
    types.ts
  database/
    sql/
      schema.sql
  listing/
    graphql/
      resolver.ts
      schema.ts
      service.ts
  message/
    graphql/
      resolver.ts
      schema.ts
      service.ts
  orders/
    graphql/
      resolver.ts
      schema.ts
      service.ts
  s3/
    graphql/
      resolver.ts
      schema.ts
tests/
  domains/
    account/
      account.test.ts
    auth/
      check.test.ts
      login.test.ts
    common/
      db/
        reset.ts
    listing/
      listing.test.ts
    message/
      message.test.ts
    orders/
      orders.test.ts
  fixtures/
    data.sql
    schema.sql
  dbTest.ts
babel.config.js
db.ts
index.ts
jest.config.js
package.json
tsconfig.json

================================================================
Files
================================================================

================
File: src/account/graphql/resolver.ts
================
// src/account/graphql/resolver.ts
import { Authorized, Query, Resolver, Ctx, Mutation, Arg } from "type-graphql";
import { Request } from "express";
import { AccountService } from "./service";
import { Account, NewAccount } from "./schema";
import { UUID, Email } from "../../common/types";
import { Service } from "typedi";
import { Public } from "../../common/decorators";

@Service()
@Resolver()
export class AccountResolver {
  constructor(private readonly accountService: AccountService) {}

  @Authorized()
  @Query(() => Account)
  async account(
    @Ctx() _req: Request,
    @Arg("input") id: UUID
  ): Promise<Account> {
    return this.accountService.getAccount(id);
  }

  @Authorized()
  @Query(() => Account)
  async accountByEmail(
    @Ctx() _req: Request,
    @Arg("input") email: Email
  ): Promise<Account> {
    return this.accountService.getAccountByEmail(email.toLowerCase());
  }

  @Authorized()
  @Query(() => [Account])
  async allAccounts(@Ctx() _req: Request): Promise<Account[]> {
    return this.accountService.getAllAccounts();
  }

  @Authorized()
  @Query(() => [Account])
  async restrictedVendors(@Ctx() _req: Request): Promise<Account[]> {
    const all = await this.accountService.getAllAccounts();
    return all.filter((acc) => acc.restricted && acc.roles.includes("Vendor"));
  }

  // Public operation: account creation is marked as public via decorator.
  @Public()
  @Mutation(() => Account)
  async makeAccount(
    @Arg("input") newAccount: NewAccount,
    @Ctx() _request: Request
  ): Promise<Account> {
    newAccount.email = newAccount.email.toLowerCase();
    return this.accountService.makeAccount(newAccount);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteAccount(
    @Arg("input") accountID: UUID,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return this.accountService.deleteAccount(accountID);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteAccountByEmail(
    @Arg("input") accountEmail: Email,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return this.accountService.deleteAccountByEmail(accountEmail.toLowerCase());
  }

  @Authorized()
  @Mutation(() => Boolean)
  async suspendAccount(
    @Arg("input") accountID: UUID,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return this.accountService.suspendAccount(accountID);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async suspendAccountByEmail(
    @Arg("input") accountEmail: Email,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return this.accountService.suspendAccountByEmail(accountEmail.toLowerCase());
  }

  @Authorized()
  @Mutation(() => Boolean)
  async resumeAccount(
    @Arg("input") accountID: UUID,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return this.accountService.resumeAccount(accountID);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async resumeAccountByEmail(
    @Arg("input") accountEmail: Email,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return this.accountService.resumeAccountByEmail(accountEmail.toLowerCase());
  }

// src/account/graphql/resolver.ts (partial change)

@Authorized()
@Mutation(() => Boolean)
async updateProfile(
  @Arg("id") id: UUID,
  @Arg("username", { nullable: true }) username?: string,
  @Arg("bio", { nullable: true }) bio?: string,
  // New optional argument:
  @Arg("profilePicture", { nullable: true }) profilePicture?: string
): Promise<boolean> {
  return this.accountService.updateProfile(id, username, bio, profilePicture);
}

}

================
File: src/account/graphql/schema.ts
================
// src/account/graphql/schema.ts
import { ObjectType, InputType, Field } from "type-graphql";
import { MinLength } from "class-validator";
import { Name, UUID, Email } from "../../common/types";

// src/account/graphql/schema.ts

@ObjectType()
export class Profile {
  @Field()
  @MinLength(1)
  username!: string;

  @Field({ nullable: true })
  bio?: string;

  // New field for profile picture URL
  @Field({ nullable: true })
  profilePicture?: string;
}

/**
 * The Account object includes a non-null profile.
 */
@ObjectType()
export class Account {
  @Field()
  id!: UUID;

  @Field()
  email!: Email;

  @Field()
  name!: Name;

  @Field(() => [String])
  roles!: string[];

  @Field()
  restricted!: boolean;

  @Field(() => Profile)
  profile!: Profile;
}

/**
 * Input for creating a new account.
 */
@InputType()
export class NewAccount {
  @Field()
  email!: Email;

  @Field()
  @MinLength(1)
  password!: string;

  @Field()
  @MinLength(1)
  firstName!: string;

  @Field()
  @MinLength(1)
  lastName!: string;

  @Field(() => [String])
  roles!: string[];

  @Field()
  @MinLength(1)
  username!: string;

  @Field({ nullable: true })
  bio?: string;
}

================
File: src/account/graphql/service.ts
================
// src/account/graphql/service.ts

import { Service } from "typedi";
import { pool } from "../../../db";
import { NewAccount, Account } from "./schema";
import { UUID, Email } from "../../common/types";

@Service()
export class AccountService {
  public async getAccount(id: UUID): Promise<Account> {
    const select = `
      SELECT
        id,
        email,
        restricted,
        data->'name' AS name,
        data->'roles' AS roles,
        data->'profile' AS profile
      FROM account
      WHERE id = $1
    `;
    const { rows } = await pool.query(select, [id]);

    if (rows.length === 0) {
      throw new Error("Account with given ID does not exist.");
    }

    const row = rows[0];
    return {
      id: row.id,
      email: row.email,
      restricted: row.restricted,
      name: row.name,
      roles: row.roles || [],
      profile: {
        username: row.profile?.username ?? "",
        bio: row.profile?.bio ?? null,
      },
    };
  }

  public async getAccountByEmail(email: Email): Promise<Account> {
    const select = `
      SELECT
        id,
        email,
        restricted,
        data->'name' as name,
        data->'roles' as roles,
        data->'profile' as profile
      FROM account
      WHERE email = $1
    `;
    const { rows } = await pool.query(select, [email]);

    if (rows.length === 0) {
      throw new Error("Account with given Email does not exist.");
    }

    const row = rows[0];
    return {
      id: row.id,
      email: row.email,
      restricted: row.restricted,
      name: row.name,
      roles: row.roles || [],
      profile: {
        username: row.profile?.username ?? "",
        bio: row.profile?.bio ?? null,
      },
    };
  }

  public async getAllAccounts(): Promise<Account[]> {
    const select = `
      SELECT
        id,
        email,
        restricted,
        data->'name' as name,
        data->'roles' as roles,
        data->'profile' as profile
      FROM account
    `;
    const { rows } = await pool.query(select);

    return rows.map((row: any) => ({
      id: row.id,
      email: row.email,
      restricted: row.restricted,
      name: row.name,
      roles: row.roles || [],
      profile: {
        username: row.profile?.username ?? "",
        bio: row.profile?.bio ?? null,
      },
    }));
  }

  public async makeAccount(info: NewAccount): Promise<Account> {
    const restrictedVal = info.roles.some(
      (role) => role.toLowerCase() === "vendor"
    );

    // Explicitly cast parameters so that PostgreSQL can infer types.
    const insert = `
      INSERT INTO account (email, restricted, data)
      VALUES (
        $1::text,
        $7,
        jsonb_build_object(
          'name', jsonb_build_object(
            'first', $2::text,
            'last', $3::text
          ),
          'password', crypt($4::text, '${process.env.CRYPT_SECRET}'),
          'roles', $5::text[],
          'profile', jsonb_build_object(
            'username', $6::text,
            'bio', $8::text
          )
        )
      )
      RETURNING id
    `;
    const values = [
      info.email,
      info.firstName,
      info.lastName,
      info.password,
      info.roles,
      info.username,
      restrictedVal,
      info.bio || null,
    ];
    const { rows } = await pool.query(insert, values);

    return {
      id: rows[0].id,
      email: info.email,
      name: { first: info.firstName, last: info.lastName },
      roles: info.roles,
      restricted: restrictedVal,
      profile: {
        username: info.username,
        bio: info.bio || undefined,
      },
    };
  }

  public async deleteAccount(id: UUID): Promise<boolean> {
    const del = `DELETE FROM account WHERE id = $1`;
    await pool.query(del, [id]);
    return true;
  }

  public async deleteAccountByEmail(email: string): Promise<boolean> {
    const del = `DELETE FROM account WHERE email = $1`;
    await pool.query(del, [email]);
    return true;
  }

  private async modifyRestricted(
    byWhat: "id" | "email",
    setTo: boolean,
    byValue: UUID | Email
  ) {
    const update = `UPDATE account SET restricted = $2 WHERE ${byWhat} = $1`;
    await pool.query(update, [byValue, setTo]);
    return true;
  }

  public async suspendAccount(id: UUID): Promise<boolean> {
    return this.modifyRestricted("id", true, id);
  }

  public async resumeAccount(id: UUID): Promise<boolean> {
    return this.modifyRestricted("id", false, id);
  }

  public async suspendAccountByEmail(email: Email): Promise<boolean> {
    return this.modifyRestricted("email", true, email);
  }

  public async resumeAccountByEmail(email: Email): Promise<boolean> {
    return this.modifyRestricted("email", false, email);
  }

  public async updateProfile(
    id: UUID,
    username?: string,
    bio?: string,
    profilePicture?: string
  ): Promise<boolean> {
    // Retrieve the current profile
    const select = `
      SELECT data->'profile' as profile
      FROM account
      WHERE id = $1
    `;
    const { rows } = await pool.query(select, [id]);

    if (rows.length === 0) {
      throw new Error("No account found for that ID.");
    }

    const oldProfile = rows[0].profile || {};
    // Merge new values if provided
    const newProfile = {
      ...oldProfile,
      ...(username !== undefined ? { username } : {}),
      ...(bio !== undefined ? { bio } : {}),
      ...(profilePicture !== undefined ? { profilePicture } : {}),
    };

    const updateSql = `
      UPDATE account
      SET data = jsonb_set(
        data,
        '{profile}',
        $2::jsonb,
        true
      )
      WHERE id = $1
    `;
    await pool.query(updateSql, [id, JSON.stringify(newProfile)]);
    return true;
  }
}

================
File: src/auth/graphql/resolver.ts
================
// src/auth/graphql/resolver.ts
import { Resolver, Mutation, Query, Ctx, Arg } from "type-graphql";
import { Authenticated, Credentials, SessionAccount } from "./schema";
import { AuthService } from "./service";
import { Service } from "typedi";
import { Request } from "express";

@Service()
@Resolver()
export class AuthResolver {
  constructor(private readonly authService: AuthService) {}

  @Mutation(() => Authenticated)
  async login(
    @Ctx() req: Request,
    @Arg("input") creds: Credentials
  ): Promise<Authenticated> {
    const account = await this.authService.login(creds);
    if (!account) {
      throw new Error("Invalid Credentials");
    }
    return account;
  }

  @Query(() => SessionAccount)
  async check(
    @Ctx() req: Request,
    @Arg("input") accessToken: string
  ): Promise<SessionAccount> {
    return this.authService.check(accessToken);
  }
}

================
File: src/auth/graphql/schema.ts
================
//Backend/src/auth/graphql/schema.ts
import { ObjectType, InputType, Field } from "type-graphql";
import {MinLength} from 'class-validator';
import {UUID, Email, Name } from '../../common/types'



@InputType()
@ObjectType()
export class Authenticated {
  @Field()
  @MinLength(1)
  id!:string

  @Field()
  name!:Name

  @Field()
  @MinLength(1)
  accessToken!:string
}

ObjectType()
export class Account {
  @Field()
  id!:UUID

  @Field()
  email!:Email

  @Field()
  name!:Name

  @Field()
  @MinLength(1)
  accessToken!:string

  // TODO: IMPLEMENT TWO TOKENS AUTH
  // @Field()
  // @MinLength(1)
  // refreshToken!:string

}

@InputType()
@ObjectType()
export class Credentials {
  @Field()
  @MinLength(1)
  email!:Email

  @Field()
  @MinLength(1)
  password!:string

}

@InputType()
@ObjectType()
export class SessionAccount {

  @Field()
  @MinLength(1)
  id!: string;

}

================
File: src/auth/graphql/service.ts
================
// src/auth/graphql/service.ts
import { Service } from "typedi";
import { pool } from "../../../db";
import * as jwt from "jsonwebtoken";
import { Credentials, Authenticated, Account, SessionAccount } from "./schema";

@Service()
export class AuthService {
  private async find(creds: Credentials): Promise<Account | undefined> {
    const select = `SELECT id, email, data->'name' as name, data->'roles' as roles FROM account 
      WHERE email = $1 AND
      (data->>'password') = crypt($2, '${process.env.CRYPT_SECRET}') AND restricted = FALSE`;
    const { rows } = await pool.query(select, [creds.email, creds.password]);
    if (rows.length !== 1) {
      return undefined;
    }
    return rows[0];
  }

  public async login(creds: Credentials): Promise<Authenticated | undefined> {
    const account = await this.find(creds);
    if (!account) {
      return undefined;
    }
    const accessToken = jwt.sign(
      {
        id: account.id,
      },
      process.env.MASTER_SECRET as string,
      { algorithm: "HS256" }
    );

    return { id: account.id, name: account.name, accessToken };
  }

  public async check(accessToken: string): Promise<SessionAccount> {
    return new Promise((resolve, reject) => {
      jwt.verify(
        accessToken,
        process.env.MASTER_SECRET as string,
        (err, decoded) => {
          if (err) {
            return reject(err);
          }
          const account = decoded as { id: string };
          resolve({ id: account.id });
        }
      );
    });
  }
}

================
File: src/common/decorators.ts
================
// src/common/decorators/Public.ts
import "reflect-metadata";

export const IS_PUBLIC_KEY = "isPublic";

/**
 * Marks a resolver method as public (i.e. does not require authentication).
 */
export function Public(): MethodDecorator {
  return (target, propertyKey, descriptor) => {
    Reflect.defineMetadata(IS_PUBLIC_KEY, true, descriptor.value!);
  };
}

================
File: src/common/s3service.ts
================
// Backend/src/common/s3Service.ts
import AWS from 'aws-sdk';

AWS.config.update({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
  region: process.env.AWS_REGION!,
});

const s3 = new AWS.S3();

export async function getPresignedUploadUrl(key: string, contentType: string, expiresIn = 60) {
  const params = {
    Bucket: process.env.AWS_S3_BUCKET!,
    Key: key,
    Expires: expiresIn,
    ContentType: contentType,
    ACL: 'public-read', // so the image is publicly available
  };

  return s3.getSignedUrlPromise('putObject', params);
}

================
File: src/common/types.ts
================
// src/common/types.ts
import { ObjectType, Field, InputType } from "type-graphql";
import { MinLength } from "class-validator";

@ObjectType()
export class Name {
  @Field()
  @MinLength(1)
  first!: string;

  @Field()
  @MinLength(1)
  last!: string;
}

/**
 * From https://tsoa-community.github.io/docs/examples.html
 * Stringified UUIDv4.
 * See [RFC 4112](https://tools.ietf.org/html/rfc4122)
 * @pattern [0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}
 * @format uuid
 */
export type UUID = string;

/**
 * From https://tsoa-community.github.io/docs/examples.html
 * Stringified UUIDv4.
 * See [RFC 4112](https://tools.ietf.org/html/rfc4122)
 * @pattern ^[\w-.]+@([\w-]+\.)+[\w-]{2,4}$
 * @format email
 */
export type Email = string;

================
File: src/database/sql/schema.sql
================
--Backend/src/database/sql/schema.sql
-- 2.schema.sql
-- Enable pgcrypto for UUID generation and crypt()
CREATE EXTENSION IF NOT EXISTS pgcrypto;

DROP TABLE IF EXISTS account CASCADE;
-- Create the account table
CREATE TABLE account (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text UNIQUE NOT NULL,
  data jsonb NOT NULL,
  restricted boolean NOT NULL DEFAULT false
);

CREATE TABLE listing (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id uuid NOT NULL,
  data jsonb NOT NULL
);

CREATE TABLE message (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  item_owner_id uuid NOT NULL,
  sender_id uuid NOT NULL,
  data jsonb NOT NULL
);

DROP TABLE IF EXISTS orders CASCADE;

CREATE TABLE orders (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- The account who placed the order
  buyer_id uuid NOT NULL,
  
  -- The account (shop or seller) fulfilling the order
  seller_id uuid NOT NULL,
  
  -- For now, we’ll store an order or shipping status as a simple text column
  shipping_status text NOT NULL DEFAULT 'pending',

  item_id uuid NOT NULL,
  
  -- Possibly a JSONB for extra data (items, totals, addresses, etc.)
  data jsonb,
  
  CONSTRAINT fk_order_buyer
    FOREIGN KEY (buyer_id)
    REFERENCES account (id)
    ON DELETE CASCADE,

  CONSTRAINT fk_order_seller
    FOREIGN KEY (seller_id)
    REFERENCES account (id)
    ON DELETE CASCADE,
  
  CONSTRAINT fk_order_item
    FOREIGN KEY (item_id)
    REFERENCES listing (id)
);

================
File: src/listing/graphql/resolver.ts
================
// src/listing/graphql/resolver.ts

import { Authorized, Query, Resolver, Mutation, Arg, Int, Ctx } from "type-graphql";
import { Request } from "express";
import { ListingService } from "./service";
import { Listing, NewListing, PaginatedListings } from "./schema";
import { UUID } from "../../common/types";
import { Service } from "typedi";

@Service()
@Resolver()
export class ListingResolver {
  constructor(private readonly listingService: ListingService) {}

  @Authorized()
  @Query(() => Listing)
  async listing(
    @Ctx() _req: Request,
    @Arg("id") id: UUID
  ): Promise<Listing> {
    return this.listingService.getListing(id);
  }

  @Authorized()
  @Query(() => PaginatedListings)
  async allListings(
    @Ctx() _req: Request,
    @Arg("page", () => Int, { defaultValue: 1 }) page: number,
    @Arg("pageSize", () => Int, { defaultValue: 10 }) pageSize: number
  ): Promise<PaginatedListings> {
    return this.listingService.getAllListings(page, pageSize);
  }

  @Authorized()
  @Mutation(() => Listing)
  async createListing(
    @Arg("input") listingInfo: NewListing,
    @Ctx() _req: Request
  ): Promise<Listing> {
    return this.listingService.createListing(listingInfo);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteListing(
    @Arg("id") listingId: UUID,
    @Ctx() _req: Request
  ): Promise<boolean> {
    return this.listingService.deleteListing(listingId);
  }

  @Authorized()
  @Query(() => PaginatedListings)
  async searchListings(
    @Arg("searchTerm") searchTerm: string,
    @Arg("page", () => Int, { defaultValue: 1 }) page: number,
    @Arg("pageSize", () => Int, { defaultValue: 10 }) pageSize: number
  ): Promise<PaginatedListings> {
    const { listings, totalCount } = await this.listingService.searchListings(
      searchTerm,
      page,
      pageSize
    );
    return { listings, totalCount };
  }

  // In src/listing/graphql/resolver.ts, add:
  @Authorized()
  @Mutation(() => Boolean)
  async updateListingImages(
    @Arg("id") id: UUID,
    @Arg("imageUrls", () => [String]) imageUrls: string[]
  ): Promise<boolean> {
    return this.listingService.updateListingImages(id, imageUrls);
  }


}

================
File: src/listing/graphql/schema.ts
================
// src/listing/graphql/schema.ts

import { Field, InputType, ObjectType, Int } from "type-graphql";
import { MinLength } from "class-validator";
import { UUID } from "../../common/types";

@ObjectType()
export class Listing {
  @Field()
  id!: UUID;

  @Field()
  ownerId!: UUID;

  @Field()
  @MinLength(1)
  brand!: string;

  @Field()
  @MinLength(1)
  name!: string;

  @Field()
  @MinLength(1)
  description!: string;

  @Field(() => [String])
  imageUrls!: string[];
}

@InputType()
export class NewListing {
  @Field()
  ownerId!: UUID;

  @Field()
  @MinLength(1)
  brand!: string;

  @Field()
  @MinLength(1)
  name!: string;

  @Field()
  @MinLength(1)
  description!: string;

  @Field(() => [String])
  imageUrls!: string[];
}

/**
 * For returning paginated listing results (listings + totalCount).
 */
@ObjectType()
export class PaginatedListings {
  @Field(() => [Listing])
  listings!: Listing[];

  @Field(() => Int)
  totalCount!: number;
}

================
File: src/listing/graphql/service.ts
================
// src/listing/graphql/service.ts

import { Service } from "typedi";
import { pool } from "../../../db";
import { NewListing, Listing, PaginatedListings } from "./schema";
import { UUID } from "../../common/types";

@Service()
export class ListingService {
  /**
   * Fetch all listings with pagination.
   * @param page The page number (>= 1).
   * @param pageSize The number of listings per page (>= 1).
   * Returns { listings, totalCount }.
   */
  public async getAllListings(
    page: number = 1,
    pageSize: number = 10
  ): Promise<PaginatedListings> {
    if (page < 1) page = 1;
    if (pageSize < 1) pageSize = 10;

    const offset = (page - 1) * pageSize;

    const countResult = await pool.query(`SELECT COUNT(*) AS total FROM listing`);
    const totalCount = parseInt(countResult.rows[0].total, 10);

    const select = `
      SELECT
        id,
        owner_id as "ownerId",
        data->>'brand' as brand,
        data->>'name' as name,
        data->>'description' as description,
        data->'imageUrls' as "imageUrls"
      FROM listing
      LIMIT $1
      OFFSET $2
    `;

    const { rows } = await pool.query(select, [pageSize, offset]);

    const listings = rows.map((row: any) => ({
      ...row,
      imageUrls: row.imageUrls || [],
    }));

    return { listings, totalCount };
  }

  /**
   * Get a single listing by ID.
   */
  public async getListing(id: UUID): Promise<Listing> {
    const select = `
      SELECT
        id,
        owner_id as "ownerId",
        data->>'brand' as brand,
        data->>'name' as name,
        data->>'description' as description,
        data->'imageUrls' as "imageUrls"
      FROM listing
      WHERE id = $1
    `;
    const { rows } = await pool.query(select, [id]);
    if (rows.length === 0) {
      throw new Error("Listing with given ID does not exist.");
    }
    rows[0].imageUrls = rows[0].imageUrls || [];
    return rows[0];
  }

  /**
   * Create a new listing.
   */
  public async createListing(info: NewListing): Promise<Listing> {
    const insert = `
      INSERT INTO listing (owner_id, data)
      VALUES (
        $1::uuid,
        jsonb_build_object(
          'brand', $2::text,
          'name', $3::text,
          'description', $4::text,
          'imageUrls', $5::text[]
        )
      )
      RETURNING id;
    `;
    const { rows } = await pool.query(insert, [
      info.ownerId,
      info.brand,
      info.name,
      info.description,
      info.imageUrls,
    ]);

    return {
      id: rows[0].id,
      ownerId: info.ownerId,
      brand: info.brand,
      name: info.name,
      description: info.description,
      imageUrls: info.imageUrls,
    };
  }

  /**
   * Delete a listing by ID.
   */
  public async deleteListing(id: UUID): Promise<boolean> {
    const del = `DELETE FROM listing WHERE id = $1`;
    await pool.query(del, [id]);
    return true;
  }

  /**
   * Search by substring in brand/name/description (case-insensitive) with pagination.
   */
  public async searchListings(
    searchTerm: string,
    page: number = 1,
    pageSize: number = 10
  ): Promise<PaginatedListings> {
    if (page < 1) page = 1;
    if (pageSize < 1) pageSize = 10;

    const ilikeValue = `%${searchTerm}%`;

    const countSql = `
      SELECT COUNT(*) AS total
      FROM listing
      WHERE
        (data->>'brand') ILIKE $1
        OR (data->>'name') ILIKE $1
        OR (data->>'description') ILIKE $1
    `;
    const countResult = await pool.query(countSql, [ilikeValue]);
    const totalCount = parseInt(countResult.rows[0].total, 10);

    const offset = (page - 1) * pageSize;
    const selectSql = `
      SELECT
        id,
        owner_id AS "ownerId",
        data->>'brand' AS brand,
        data->>'name' AS name,
        data->>'description' AS description,
        data->'imageUrls' AS "imageUrls"
      FROM listing
      WHERE
        (data->>'brand') ILIKE $1
        OR (data->>'name') ILIKE $1
        OR (data->>'description') ILIKE $1
      LIMIT $2
      OFFSET $3
    `;

    const { rows } = await pool.query(selectSql, [ilikeValue, pageSize, offset]);

    const listings = rows.map((r: any) => ({
      ...r,
      imageUrls: r.imageUrls || [],
    }));

    return { listings, totalCount };
  }

  // In src/listing/graphql/service.ts, add:
  public async updateListingImages(id: UUID, imageUrls: string[]): Promise<boolean> {
    const updateSql = `
      UPDATE listing
      SET data = jsonb_set(
        data,
        '{imageUrls}',
        $2::jsonb,
        true
      )
      WHERE id = $1
    `;
    await pool.query(updateSql, [id, JSON.stringify(imageUrls)]);
    return true;
  }

}

================
File: src/message/graphql/resolver.ts
================
// src/message/graphql/resolver.ts

import { Authorized, Query, Resolver, Ctx, Mutation, Arg } from "type-graphql";
import { Request } from "express";
import { MessageService } from "./service";
import { Message, NewMessage } from "./schema";
import { UUID } from "../../common/types";
import { Service } from "typedi";

@Service()
@Resolver()
export class MessageResolver {
  constructor(private readonly messageService: MessageService) {}

  @Authorized()
  @Query(() => Message)
  async message(
    @Ctx() _req: Request,
    @Arg("input") id: UUID
  ): Promise<Message> {
    return this.messageService.getMessage(id);
  }

  @Authorized()
  @Query(() => [Message])
  async messagesByItemOwner(
    @Ctx() _req: Request,
    @Arg("input") itemOwnerId: UUID
  ): Promise<Message[]> {
    return this.messageService.getMessagesByItemOwner(itemOwnerId);
  }

  @Authorized()
  @Query(() => [Message])
  async messagesBySender(
    @Ctx() _req: Request,
    @Arg("input") senderId: UUID
  ): Promise<Message[]> {
    return this.messageService.getMessagesBySender(senderId);
  }

  @Authorized()
  @Mutation(() => Message)
  async createMessage(
    @Arg("input") messageInfo: NewMessage,
    @Ctx() _req: Request
  ): Promise<Message> {
    return this.messageService.createMessage(messageInfo);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteMessage(
    @Arg("input") messageId: UUID,
    @Ctx() _req: Request
  ): Promise<boolean> {
    return this.messageService.deleteMessage(messageId);
  }
}

================
File: src/message/graphql/schema.ts
================
// src/message/graphql/schema.ts

import { Field, InputType, ObjectType } from "type-graphql";
import { MinLength } from "class-validator";
import { UUID } from "../../common/types";

@ObjectType()
export class Message {
  @Field()
  id!: UUID;

  @Field()
  itemOwnerId!: UUID;

  @Field()
  senderId!: UUID;

  @Field()
  @MinLength(1)
  content!: string;
}

@InputType()
export class NewMessage {
  @Field()
  itemOwnerId!: UUID;

  @Field()
  senderId!: UUID;

  @Field()
  @MinLength(1)
  content!: string;
}

================
File: src/message/graphql/service.ts
================
// src/message/graphql/service.ts

import { Service } from "typedi";
import { pool } from "../../../db";
import { NewMessage, Message } from "./schema";
import { UUID } from "../../common/types";

@Service()
export class MessageService {
  public async getMessage(id: UUID): Promise<Message> {
    const select = `
      SELECT id, 
             item_owner_id as "itemOwnerId", 
             sender_id as "senderId", 
             data->>'content' as content
      FROM message 
      WHERE id = $1
    `;
    const { rows } = await pool.query(select, [id]);
    if (rows.length === 0) {
      throw new Error("Message not found.");
    }
    return rows[0];
  }

  public async getMessagesByItemOwner(itemOwnerId: UUID): Promise<Message[]> {
    const select = `
      SELECT id, 
             item_owner_id as "itemOwnerId", 
             sender_id as "senderId", 
             data->>'content' as content
      FROM message 
      WHERE item_owner_id = $1
    `;
    const { rows } = await pool.query(select, [itemOwnerId]);
    return rows;
  }

  public async getMessagesBySender(senderId: UUID): Promise<Message[]> {
    const select = `
      SELECT id, 
             item_owner_id as "itemOwnerId", 
             sender_id as "senderId", 
             data->>'content' as content
      FROM message 
      WHERE sender_id = $1
    `;
    const { rows } = await pool.query(select, [senderId]);
    return rows;
  }

  public async createMessage(info: NewMessage): Promise<Message> {
    const insert = `
      INSERT INTO message(item_owner_id, sender_id, data)
      VALUES ($1::uuid, $2::uuid, jsonb_build_object('content', $3::text))
      RETURNING id;
    `;
    const { rows } = await pool.query(insert, [
      info.itemOwnerId,
      info.senderId,
      info.content,
    ]);
    return {
      id: rows[0].id,
      itemOwnerId: info.itemOwnerId,
      senderId: info.senderId,
      content: info.content,
    };
  }

  public async deleteMessage(id: UUID): Promise<boolean> {
    const del = `DELETE FROM message WHERE id = $1`;
    await pool.query(del, [id]);
    return true;
  }
}

================
File: src/orders/graphql/resolver.ts
================
// src/orders/graphql/resolver.ts

import { Authorized, Resolver, Query, Mutation, Arg } from "type-graphql";
import { OrderService } from "./service";
import { Order, NewOrder, UUID, ShippingStatus } from "./schema";

@Resolver()
export class OrderResolver {
  private readonly orderService = new OrderService();

  @Authorized()
  @Query(() => Order)
  async order(@Arg("id") id: UUID): Promise<Order> {
    return this.orderService.getOrder(id);
  }

  @Authorized()
  @Query(() => [Order])
  async allOrders(): Promise<Order[]> {
    return this.orderService.getAllOrders();
  }

  @Authorized()
  @Mutation(() => Order)
  async createOrder(@Arg("input") input: NewOrder): Promise<Order> {
    return this.orderService.createOrder(input);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteOrder(@Arg("id") id: UUID): Promise<boolean> {
    return this.orderService.deleteOrder(id);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async updateOrderStatus(
    @Arg("id") id: UUID,
    @Arg("status", () => ShippingStatus) status: ShippingStatus
  ): Promise<boolean> {
    return this.orderService.updateShippingStatus(id, status);
  }
}

================
File: src/orders/graphql/schema.ts
================
//Backend/src/orders/graphql/schema.ts
import { Field, InputType, ObjectType, registerEnumType } from "type-graphql";
import { MinLength } from "class-validator";

/**
 * From your listing schema example:
 * @pattern [0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}
 * @format uuid
 */
export type UUID = string;

/**
 * Example shipping statuses. Feel free to add or change these.
 */
export enum ShippingStatus {
  PENDING = "PENDING",
  SHIPPED = "SHIPPED",
  DELIVERED = "DELIVERED",
  CANCELLED = "CANCELLED",
}

/**
 * Let TypeGraphQL know about our enum so it can generate correct schema types.
 */
registerEnumType(ShippingStatus, {
  name: "ShippingStatus",
});

@ObjectType()
export class Order {
  @Field()
  id!: UUID;

  // The account who placed the order
  @Field()
  buyerId!: UUID;

  // The account fulfilling the order (e.g. vendor or seller)
  @Field()
  sellerId!: UUID;

  @Field()
  itemId!: UUID;

  // Current shipping status of the order
  @Field(() => ShippingStatus)
  shippingStatus!: ShippingStatus;

  // Optionally store extra info
  // e.g., items, addresses, timestamps, etc.
  @Field({ nullable: true })
  data?: string;
}

@InputType()
export class NewOrder {
  @Field()
  buyerId!: UUID;

  @Field()
  sellerId!: UUID;

  @Field()
  itemId!: UUID; // ensure you capture itemId if needed

  @Field(() => ShippingStatus, { nullable: true })
  shippingStatus?: ShippingStatus;

  @Field({ nullable: true })
  @MinLength(1)
  data?: string;
}

================
File: src/orders/graphql/service.ts
================
//Backend/src/orders/graphql/service.ts
import { pool } from '../../../db';
import { NewOrder, Order, ShippingStatus, UUID } from './schema';

export class OrderService {
  /**
   * Fetch a single order by id.
   */
  public async getOrder(id: UUID): Promise<Order> {
    const select = `
      SELECT
        id,
        buyer_id,
        seller_id,
        item_id,
        shipping_status,
        data
      FROM orders
      WHERE id = $1
    `;
    const query = {
      text: select,
      values: [id],
    };
    const { rows } = await pool.query(query);

    if (rows.length === 0) {
      throw new Error('Order with given ID does not exist.');
    }

    // Convert row to Order object
    const row = rows[0];
    return {
      id: row.id,
      buyerId: row.buyer_id,
      sellerId: row.seller_id,
      itemId: row.item_id,
      shippingStatus: row.shipping_status as ShippingStatus,
      data: row.data || undefined,
    };
  }

  /**
   * Fetch all orders in the system (or optionally filter).
   */
  public async getAllOrders(): Promise<Order[]> {
    const select = `
      SELECT
        id,
        buyer_id,
        seller_id,
        item_id,
        shipping_status,
        data
      FROM orders
    `;
    const { rows } = await pool.query(select);

    return rows.map((row) => ({
      id: row.id,
      buyerId: row.buyer_id,
      sellerId: row.seller_id,
      itemId: row.item_id,
      shippingStatus: row.shipping_status as ShippingStatus,
      data: row.data || undefined,
    }));
  }

  /**
   * Create a new order in the DB.
   * shippingStatus defaults to 'PENDING' if not provided.
   */
  public async createOrder(info: NewOrder): Promise<Order> {
    const status = info.shippingStatus || ShippingStatus.PENDING;
    
    const insert = `
      INSERT INTO orders (buyer_id, seller_id, shipping_status, item_id, data)
      VALUES ($1::uuid, $2::uuid, $3::text, $4::uuid, $5::jsonb)
      RETURNING id
    `;
    const query = {
      text: insert,
      values: [
        info.buyerId,
        info.sellerId,
        status,
        info.itemId, // <--- pass the itemId now
        info.data ? JSON.stringify(info.data) : null,
      ],
    };
    
    const { rows } = await pool.query(query);
    const id = rows[0].id as UUID;
  
    return {
      id,
      buyerId: info.buyerId,
      sellerId: info.sellerId,
      itemId: info.itemId,
      shippingStatus: status,
      data: info.data,
    };
  }

  /**
   * Delete an order by id.
   * Returns true if deleted successfully, false if not found (optional).
   */
  public async deleteOrder(id: UUID): Promise<boolean> {
    const del = `
      DELETE FROM orders
      WHERE id = $1
    `;
    const query = {
      text: del,
      values: [id],
    };

    const result = await pool.query(query);
    // result.rowCount === 1 if a row was deleted
    return result.rowCount === 1;
  }

  /**
   * Update the shipping status for a given order.
   */
  public async updateShippingStatus(
    id: UUID,
    newStatus: ShippingStatus
  ): Promise<boolean> {
    const update = `
      UPDATE orders
      SET shipping_status = $2
      WHERE id = $1
    `;
    const query = {
      text: update,
      values: [id, newStatus],
    };

    const result = await pool.query(query);
    return result.rowCount === 1; // true if an order was updated
  }
}

================
File: src/s3/graphql/resolver.ts
================
// Backend/src/s3/graphql/resolver.ts
import { Resolver, Mutation, Arg } from "type-graphql";
import { S3UploadUrl } from "./schema";
import { getPresignedUploadUrl } from "../../common/s3service";

@Resolver()
export class S3Resolver {
  /**
   * Generate a pre-signed URL for uploading an image.
   * @param fileName - original filename (used as a base)
   * @param contentType - the MIME type of the file (e.g. image/jpeg)
   * @param folder - a folder string to separate profile images and listing images (e.g. "profile" or "listing")
   */
  @Mutation(() => S3UploadUrl)
  async generateUploadUrl(
    @Arg("fileName") fileName: string,
    @Arg("contentType") contentType: string,
    @Arg("folder") folder: string
  ): Promise<S3UploadUrl> {
    // Generate a unique key – here we prefix the filename with folder and a timestamp.
    const key = `${folder}/${Date.now()}_${fileName}`;
    const preSignedUrl = await getPresignedUploadUrl(key, contentType);
    const fileUrl = `https://${process.env.AWS_S3_BUCKET}.s3.${process.env.AWS_REGION}.amazonaws.com/${key}`;
    return { preSignedUrl, fileUrl };
  }
}

================
File: src/s3/graphql/schema.ts
================
// Backend/src/s3/graphql/schema.ts
import { ObjectType, Field, InputType } from "type-graphql";

@ObjectType()
export class S3UploadUrl {
  @Field()
  preSignedUrl!: string;

  @Field()
  fileUrl!: string;
}

================
File: tests/domains/account/account.test.ts
================
// tests/domains/account/account.test.ts

import * as http from "http";
import supertest from "supertest";
import { createApp } from "../../../index";
import { resetGlobal, shutdown } from "../common/db/reset";

let server: http.Server;
let token = "";

beforeAll(async () => {
  // Reset the test database using global fixtures.
  await resetGlobal();
  const app = await createApp();
  server = http.createServer(app);
  server.listen(0);

  // Login (using the mutation) to get a token for protected operations.
  const loginResponse = await supertest(server)
    .post("/graphql")
    .send({
      query: `
        mutation login {
          login(input: { email: "test@example.com", password: "password" }) {
            accessToken
          }
        }
      `
    });
  if (!loginResponse.body.data || !loginResponse.body.data.login) {
    throw new Error(`Login failed. Response: ${JSON.stringify(loginResponse.body)}`);
  }
  token = loginResponse.body.data.login.accessToken;
}, 10000);

afterAll((done) => {
  // Shutdown the DB pool and then close the HTTP server.
  shutdown(() => {
    server.close(done);
  });
});

let id = "";

describe("Account Resolver Tests", () => {
  it("Can get member by ID", async () => {
    // This fixed ID is seeded via the global fixtures.
    const seededId = "00000000-0000-0000-0000-000000000001";
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          account(input: "${seededId}") {
            id
            name { first last }
            email
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.account.email).toBe("sammy@slugmart.com");
        expect(res.body.data.account.name.first).toBe("Sammy");
        expect(res.body.data.account.name.last).toBe("Slug");
      });
  });

  it("Cant get member by non-existent ID", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          account(input: "10000000-0000-0000-0000-000000000000") {
            id
            name { first last }
            email
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  it("Can get member by email", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          accountByEmail(input: "sammy@slugmart.com") {
            id
            name { first last }
            email
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.accountByEmail.email).toBe("sammy@slugmart.com");
        expect(res.body.data.accountByEmail.name.first).toBe("Sammy");
        expect(res.body.data.accountByEmail.name.last).toBe("Slug");
      });
  });

  it("Cant get member by non-existent email", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          accountByEmail(input: "noEmail@slugmart.com") {
            id
            name { first last }
            email
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  // "makeAccount" is a public operation.
  it("Can make account", async () => {
    await supertest(server)
      .post("/graphql")
      .send({
        query: `mutation m {
          makeAccount(input: {
            email: "SlugAdmin@mart.com",
            password: "abc",
            firstName: "Slug",
            lastName: "min",
            username: "slugadmin",
            roles: ["Admin", "Shopper"]
          }) {
            id
            email
            name { first last }
            roles
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.makeAccount.email).toBe("slugadmin@mart.com");
        expect(res.body.data.makeAccount.name.first).toBe("Slug");
        expect(res.body.data.makeAccount.name.last).toBe("min");
        id = res.body.data.makeAccount.id;
        expect(id).toBeTruthy();
      });
  });

  it("Cant make account with same email address", async () => {
    await supertest(server)
      .post("/graphql")
      .send({
        query: `mutation m {
          makeAccount(input: {
            email: "SlugAdmin@mart.com",
            password: "abc",
            firstName: "Slug",
            lastName: "min",
            username: "slugadmin",
            roles: ["Admin", "Shopper"]
          }) {
            id
            email
            name { first last }
            roles
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  it("Can delete account", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation delete {
          deleteAccount(input: "${id}")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.deleteAccount).toBe(true);
      });
  });

  it("Member should no longer exist", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          account(input: "${id}") {
            id
            name { first last }
            email
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  // Re-create the account for further suspend/resume tests.
  it("Make another account", async () => {
    await supertest(server)
      .post("/graphql")
      .send({
        query: `mutation m {
          makeAccount(input: {
            email: "SlugAdmin@mart.com",
            password: "abc",
            firstName: "Slug",
            lastName: "min",
            username: "slugadmin",
            roles: ["Admin", "Shopper"]
          }) {
            id
            email
            name { first last }
            roles
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.makeAccount.email).toBe("slugadmin@mart.com");
        expect(res.body.data.makeAccount.name.first).toBe("Slug");
        expect(res.body.data.makeAccount.name.last).toBe("min");
        id = res.body.data.makeAccount.id;
        expect(id).toBeTruthy();
      });
  });

  it("Can delete account by email", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation delete {
          deleteAccountByEmail(input: "SlugAdmin@mart.com")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.deleteAccountByEmail).toBe(true);
      });
  });

  it("Member should no longer exist (by email)", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          accountByEmail(input: "slugadmin@mart.com") {
            id
            name { first last }
            email
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  // Re-create the account again for suspend/resume tests.
  it("Make another account (again)", async () => {
    await supertest(server)
      .post("/graphql")
      .send({
        query: `mutation m {
          makeAccount(input: {
            email: "SlugAdmin@mart.com",
            password: "abc",
            firstName: "Slug",
            lastName: "min",
            username: "slugadmin",
            roles: ["Admin", "Shopper"]
          }) {
            id
            email
            name { first last }
            roles
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.makeAccount.email).toBe("slugadmin@mart.com");
        expect(res.body.data.makeAccount.name.first).toBe("Slug");
        expect(res.body.data.makeAccount.name.last).toBe("min");
        id = res.body.data.makeAccount.id;
        expect(id).toBeTruthy();
      });
  });

  it("Can suspend account by ID", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation suspend {
          suspendAccount(input: "${id}")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.suspendAccount).toBe(true);
      });
  });

  it("Account should be suspended", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          account(input: "${id}") {
            id
            name { first last }
            email
            restricted
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.account.restricted).toBe(true);
      });
  });

  it("Can resume account by ID", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation resume {
          resumeAccount(input: "${id}")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.resumeAccount).toBe(true);
      });
  });

  it("Account should not be suspended", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          account(input: "${id}") {
            id
            name { first last }
            email
            restricted
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.account.restricted).toBe(false);
      });
  });

  it("Can suspend account by email", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation suspend {
          suspendAccountByEmail(input: "slugadmin@mart.com")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.suspendAccountByEmail).toBe(true);
      });
  });

  it("Account should be suspended (by email)", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          accountByEmail(input: "slugadmin@mart.com") {
            id
            name { first last }
            email
            restricted
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.accountByEmail.restricted).toBe(true);
      });
  });

  it("Can resume account by email", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation resume {
          resumeAccountByEmail(input: "slugadmin@mart.com")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.resumeAccountByEmail).toBe(true);
      });
  });

  it("Account should not be suspended (by email)", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          accountByEmail(input: "slugadmin@mart.com") {
            id
            name { first last }
            email
            restricted
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.accountByEmail.restricted).toBe(false);
      });
  });

  it("Can get all accounts", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query g {
          allAccounts {
            id
            email
            name { first last }
            roles
            restricted
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(Array.isArray(res.body.data.allAccounts)).toBe(true);
        expect(res.body.data.allAccounts.length).toBeGreaterThan(0);
      });
  });
});

================
File: tests/domains/auth/check.test.ts
================
// tests/domains/auth/check.test.ts

import { gql, request } from "graphql-request";
import * as http from "http";
import { AddressInfo } from "net";
import { createApp } from "../../../index";
import { resetGlobal, shutdown } from "../common/db/reset";

let server: http.Server;
let endpoint: string;

beforeAll(async () => {
  await resetGlobal();
  const app = await createApp();
  server = http.createServer(app);
  await new Promise<void>((resolve) => {
    server.listen(0, () => {
      const address = server.address() as AddressInfo;
      endpoint = `http://localhost:${address.port}/graphql`;
      resolve();
    });
  });
}, 10000);

afterAll((done) => {
  shutdown(() => server.close(done));
});

interface LoginForCheckResponse {
  login: {
    id: string;
    accessToken: string;
  };
}

interface CheckResponse {
  check: {
    id: string;
  };
}

describe("AuthService check", () => {
  let accessToken: string;
  beforeAll(async () => {
    const loginQuery = gql`
      mutation Login($input: Credentials!) {
        login(input: $input) {
          id
          accessToken
        }
      }
    `;
    const variables = {
      input: { email: "test@example.com", password: "password" },
    };
    const response = await request<LoginForCheckResponse>(
      endpoint,
      loginQuery,
      variables
    );
    accessToken = response.login.accessToken;
  });

  it("should return an account id with a valid token", async () => {
    const checkQuery = gql`
      query Check($input: String!) {
        check(input: $input) {
          id
        }
      }
    `;
    const checkVars = { input: accessToken };

    const checkResponse = await request<CheckResponse>(
      endpoint,
      checkQuery,
      checkVars,
      { authorization: `Bearer ${accessToken}` }
    );

    expect(checkResponse.check.id).toBeTruthy();
  });
});

================
File: tests/domains/auth/login.test.ts
================
// tests/domains/auth/login.test.ts

import { gql, request } from "graphql-request";
import * as http from "http";
import { AddressInfo } from "net";
import { createApp } from "../../../index";
import { resetGlobal, shutdown } from "../common/db/reset";

let server: http.Server;
let endpoint = "";

beforeAll(async () => {
  await resetGlobal();
  const app = await createApp();
  server = http.createServer(app);
  await new Promise<void>((resolve) => {
    server.listen(0, () => {
      const address = server.address() as AddressInfo;
      endpoint = `http://localhost:${address.port}/graphql`;
      resolve();
    });
  });
}, 10000);

afterAll((done) => {
  shutdown(() => server.close(done));
});

interface LoginResponse {
  login: {
    id: string;
    name: { first: string; last: string };
    accessToken: string;
  };
}

describe("AuthService login", () => {
  it("should login with valid credentials", async () => {
    const query = gql`
      mutation Login($input: Credentials!) {
        login(input: $input) {
          id
          name {
            first
            last
          }
          accessToken
        }
      }
    `;
    const variables = {
      input: { email: "test@example.com", password: "password" },
    };
    const response = await request<LoginResponse>(endpoint, query, variables);
    expect(response.login).toBeDefined();
    expect(response.login.id).toBeTruthy();
    expect(response.login.name.first).toBe("John");
    expect(response.login.name.last).toBe("Doe");
    expect(response.login.accessToken).toBeTruthy();
  });

  it("should return an error for invalid credentials", async () => {
    const query = gql`
      mutation Login($input: Credentials!) {
        login(input: $input) {
          id
          name {
            first
            last
          }
          accessToken
        }
      }
    `;
    const variables = {
      input: { email: "wrong@example.com", password: "wrongpass" },
    };
    // Expect the promise to be rejected with an error message containing "Invalid Credentials"
    await expect(request<LoginResponse>(endpoint, query, variables))
      .rejects.toThrow(/Invalid Credentials/);
  });
});

================
File: tests/domains/common/db/reset.ts
================
// tests/domains/common/db/reset.ts

import { pool } from "../../../../db";
import dotenv from "dotenv";
import * as fs from "fs";
import * as path from "path";

dotenv.config();

async function runSqlFile(filePath: string): Promise<void> {
  const content = fs.readFileSync(filePath, "utf8");
  await pool.query(content);
  console.log(`Executed SQL file: ${filePath}`);
}

/**
 * Resets the entire test database using the global fixtures.
 */
export async function resetGlobal(): Promise<void> {
  const fixturesPath = path.join(__dirname, "..", "..", "..", "fixtures");
  const schemaFile = path.join(fixturesPath, "schema.sql");
  const dataFile = path.join(fixturesPath, "data.sql");

  if (fs.existsSync(schemaFile)) {
    await runSqlFile(schemaFile);
  } else {
    throw new Error(`Global schema file not found at: ${schemaFile}`);
  }

  if (fs.existsSync(dataFile)) {
    await runSqlFile(dataFile);
  } else {
    throw new Error(`Global data file not found at: ${dataFile}`);
  }
}

/**
 * Shut down the pool entirely.
 */
export function shutdown(done: Function): void {
  pool.end(() => done());
}

================
File: tests/domains/listing/listing.test.ts
================
import * as http from "http";
import supertest from "supertest";
import { createApp } from "../../../index";
import { resetGlobal, shutdown } from "../common/db/reset";

let server: http.Server;
let token = "";

beforeAll(async () => {
  await resetGlobal();
  const app = await createApp();
  server = http.createServer(app);
  server.listen(0);

  // Login to obtain a valid token for protected operations
  const loginResponse = await supertest(server)
    .post("/graphql")
    .send({
      query: `
        query login {
          login(input: { email: "test@example.com", password: "password" }) {
            accessToken
          }
        }
      `
    });
  token = loginResponse.body.data.login.accessToken;
}, 10000);

afterAll((done) => {
  shutdown(() => server.close(done));
});

let createdListingId = "";

describe("Listing Resolver Tests", () => {
  it("Can get listing by ID", async () => {
    // Use a fixed seeded listing ID from the global fixtures
    const existingId = "00000000-0000-0000-0000-000000000010";
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          listing(id: "${existingId}") {
            id
            ownerId
            brand
            name
            description
            imageUrls
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.listing.id).toBe(existingId);
        expect(res.body.data.listing.brand).toBe("TestBrand");
        expect(res.body.data.listing.name).toBe("TestName");
        expect(res.body.data.listing.description).toBe("A test description");
        expect(Array.isArray(res.body.data.listing.imageUrls)).toBe(true);
      });
  });

  it("Cant get listing by non-existent ID", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          listing(id: "10000000-0000-0000-0000-000000000000") {
            id
            ownerId
            brand
            name
            description
            imageUrls
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  it("Can get all listings (paginated)", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `
          query getAllListings {
            allListings(page: 1, pageSize: 10) {
              listings {
                id
                ownerId
                brand
                name
                description
                imageUrls
              }
              totalCount
            }
          }
        `
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const data = res.body.data.allListings;
        expect(data).toBeDefined();
        expect(Array.isArray(data.listings)).toBe(true);
        expect(data.listings.length).toBeGreaterThan(0);
        expect(typeof data.totalCount).toBe("number");
        expect(data.totalCount).toBeGreaterThan(0);
      });
  });

  it("Can create a new listing", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation create {
          createListing(input: {
            ownerId: "00000000-0000-0000-0000-000000000001",
            brand: "NewBrand",
            name: "NewItem",
            description: "Brand new test item",
            imageUrls: ["http://example.com/image1.jpg", "http://example.com/image2.jpg"]
          }) {
            id
            ownerId
            brand
            name
            description
            imageUrls
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const listing = res.body.data.createListing;
        expect(listing.id).toBeDefined();
        expect(listing.ownerId).toBe("00000000-0000-0000-0000-000000000001");
        expect(listing.brand).toBe("NewBrand");
        expect(listing.name).toBe("NewItem");
        expect(listing.description).toBe("Brand new test item");
        expect(listing.imageUrls.length).toBe(2);
        createdListingId = listing.id;
      });
  });

  it("Can delete listing", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation delete {
          deleteListing(id: "${createdListingId}")
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.deleteListing).toBe(true);
      });
  });

  it("Deleted listing should no longer exist", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          listing(id: "${createdListingId}") {
            id
            ownerId
            brand
            name
            description
            imageUrls
          }
        }`
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });

  it("Can search for listings by partial brand", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `
          query search {
            searchListings(searchTerm: "test", page: 1, pageSize: 10) {
              listings {
                id
                brand
              }
              totalCount
            }
          }
        `
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const data = res.body.data.searchListings;
        expect(data).toBeDefined();
        expect(data.totalCount).toBeGreaterThan(0);
        expect(data.listings.length).toBeGreaterThan(0);
        const first = data.listings[0];
        expect(first.brand.toLowerCase()).toContain("test");
      });
  });

  it("Returns empty search results if no listing matches", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `
          query search {
            searchListings(searchTerm: "xyzzznotfound", page: 1, pageSize: 10) {
              listings {
                id
                brand
                name
              }
              totalCount
            }
          }
        `
      })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const data = res.body.data.searchListings;
        expect(data.totalCount).toBe(0);
        expect(data.listings.length).toBe(0);
      });
  });

  it("Can search with pagination", async () => {
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `
          query search {
            searchListings(searchTerm: "test", page: 1, pageSize: 1) {
              listings {
                id
                brand
                name
              }
              totalCount
            }
          }
        `
      })
      .expect(200)
      .then(async (res) => {
        expect(res.body.errors).toBeUndefined();
        const data = res.body.data.searchListings;
        expect(data.totalCount).toBeGreaterThanOrEqual(1);
        expect(data.listings.length).toBeLessThanOrEqual(1);
        const secondPageRes = await supertest(server)
          .post("/graphql")
          .set("Authorization", `Bearer ${token}`)
          .send({
            query: `
              query search2 {
                searchListings(searchTerm: "test", page: 2, pageSize: 1) {
                  listings {
                    id
                    brand
                    name
                  }
                  totalCount
                }
              }
            `
          });
        expect(secondPageRes.body.errors).toBeUndefined();
        const secondData = secondPageRes.body.data.searchListings;
        if (data.totalCount > 1) {
          expect(secondData.listings.length).toBe(1);
        } else {
          expect(secondData.listings.length).toBe(0);
        }
      });
  });
});

================
File: tests/domains/message/message.test.ts
================
import * as http from "http";
import supertest from "supertest";
import { createApp } from "../../../index";
import { resetGlobal, shutdown } from "../common/db/reset";

let server: http.Server;
let token = "";

beforeAll(async () => {
  await resetGlobal();
  const app = await createApp();
  server = http.createServer(app);
  server.listen(0);

  // Login to obtain a valid token for protected operations
  const loginResponse = await supertest(server)
    .post("/graphql")
    .send({
      query: `
        query login {
          login(input: { email: "test@example.com", password: "password" }) {
            accessToken
          }
        }
      `
    });
  token = loginResponse.body.data.login.accessToken;
}, 10000);

afterAll((done) => {
  shutdown(() => server.close(done));
});

let createdMessageId = "";
const existingItemOwnerId = "00000000-0000-0000-0000-000000000010";
const existingSenderId = "00000000-0000-0000-0000-000000000002";

describe("Message Resolver Tests", () => {
  it("Can create a new message", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation create {
          createMessage(input: {
            itemOwnerId: "${existingItemOwnerId}",
            senderId: "${existingSenderId}",
            content: "Hello, is this item still available?"
          }) {
            id
            itemOwnerId
            senderId
            content
          }
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeUndefined();
    const msg = res.body.data.createMessage;
    expect(msg.id).toBeDefined();
    expect(msg.itemOwnerId).toBe(existingItemOwnerId);
    expect(msg.senderId).toBe(existingSenderId);
    expect(msg.content).toBe("Hello, is this item still available?");
    createdMessageId = msg.id;
  });

  it("Can get message by ID", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          message(input: "${createdMessageId}") {
            id
            itemOwnerId
            senderId
            content
          }
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeUndefined();
    const msg = res.body.data.message;
    expect(msg.id).toBe(createdMessageId);
    expect(msg.itemOwnerId).toBe(existingItemOwnerId);
    expect(msg.senderId).toBe(existingSenderId);
    expect(msg.content).toBe("Hello, is this item still available?");
  });

  it("Can get messages by itemOwnerId", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          messagesByItemOwner(input: "${existingItemOwnerId}") {
            id
            itemOwnerId
            senderId
            content
          }
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeUndefined();
    const msgs = res.body.data.messagesByItemOwner;
    expect(Array.isArray(msgs)).toBe(true);
    expect(msgs.length).toBeGreaterThan(0);
    expect(msgs.some((m: any) => m.id === createdMessageId)).toBe(true);
  });

  it("Can get messages by senderId", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          messagesBySender(input: "${existingSenderId}") {
            id
            itemOwnerId
            senderId
            content
          }
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeUndefined();
    const msgs = res.body.data.messagesBySender;
    expect(Array.isArray(msgs)).toBe(true);
    expect(msgs.length).toBeGreaterThan(0);
    expect(msgs.some((m: any) => m.id === createdMessageId)).toBe(true);
  });

  it("Cant get message by non-existent ID", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          message(input: "10000000-0000-0000-0000-000000000000") {
            id
            itemOwnerId
            senderId
            content
          }
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeDefined();
    expect(res.body.errors.length).toBeGreaterThan(0);
  });

  it("Can delete message", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `mutation del {
          deleteMessage(input: "${createdMessageId}")
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeUndefined();
    expect(res.body.data.deleteMessage).toBe(true);
  });

  it("Deleted message should no longer exist", async () => {
    const res = await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({
        query: `query get {
          message(input: "${createdMessageId}") {
            id
            itemOwnerId
            senderId
            content
          }
        }`
      })
      .expect(200);
    expect(res.body.errors).toBeDefined();
    expect(res.body.errors.length).toBeGreaterThan(0);
  });
});

================
File: tests/domains/orders/orders.test.ts
================
import * as http from "http";
import supertest from "supertest";
import { createApp } from "../../../index";
import { resetGlobal, shutdown } from "../common/db/reset";

let orderId = "";
let server: http.Server;
let token = "";

beforeAll(async () => {
  await resetGlobal();
  const app = await createApp();
  server = http.createServer(app);
  server.listen(0);

  // Login to obtain a valid token for protected operations
  const loginResponse = await supertest(server)
    .post("/graphql")
    .send({
      query: `
        query login {
          login(input: { email: "test@example.com", password: "password" }) {
            accessToken
          }
        }
      `
    });
  token = loginResponse.body.data.login.accessToken;
}, 10000);

afterAll((done) => {
  shutdown(() => server.close(done));
});

describe("Order Resolver Tests", () => {
  it("Can create a new order", async () => {
    const buyerId = "00000000-0000-0000-0000-000000000002"; // from global seed
    const sellerId = "00000000-0000-0000-0000-000000000001"; // from global seed
    const itemId = "00000000-0000-0000-0000-000000000010"; // seeded listing
    const mutation = `
      mutation create {
        createOrder(input: {
          buyerId: "${buyerId}",
          sellerId: "${sellerId}",
          itemId: "${itemId}",
          shippingStatus: PENDING,
          data: "LineItems or JSON data"
        }) {
          id
          buyerId
          sellerId
          shippingStatus
          data
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query: mutation })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const created = res.body.data.createOrder;
        expect(created).toBeDefined();
        expect(created.buyerId).toBe(buyerId);
        expect(created.sellerId).toBe(sellerId);
        expect(created.shippingStatus).toBe("PENDING");
        expect(created.data).toBe("LineItems or JSON data");
        orderId = created.id;
      });
  });

  it("Can fetch order by id", async () => {
    const query = `
      query get {
        order(id: "${orderId}") {
          id
          buyerId
          sellerId
          shippingStatus
          data
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const fetched = res.body.data.order;
        expect(fetched).toBeDefined();
        expect(fetched.id).toBe(orderId);
      });
  });

  it("Can update shipping status", async () => {
    const mutation = `
      mutation update {
        updateOrderStatus(id: "${orderId}", status: SHIPPED)
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query: mutation })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.updateOrderStatus).toBe(true);
      });
    const checkQuery = `
      query check {
        order(id: "${orderId}") {
          id
          shippingStatus
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query: checkQuery })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.order.shippingStatus).toBe("SHIPPED");
      });
  });

  it("Can fetch all orders", async () => {
    const query = `
      query getAll {
        allOrders {
          id
          buyerId
          sellerId
          shippingStatus
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const orders = res.body.data.allOrders;
        expect(Array.isArray(orders)).toBe(true);
        expect(orders.length).toBeGreaterThan(0);
        const found = orders.find((o: any) => o.id === orderId);
        expect(found).toBeDefined();
      });
  });

  it("Can delete an order", async () => {
    const mutation = `
      mutation remove {
        deleteOrder(id: "${orderId}")
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query: mutation })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.deleteOrder).toBe(true);
      });
    const checkQuery = `
      query check {
        order(id: "${orderId}") {
          id
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .set("Authorization", `Bearer ${token}`)
      .send({ query: checkQuery })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });
});

================
File: tests/fixtures/data.sql
================
-- tests/fixtures/data.sql
-- Global seed data for tests

-- Seed accounts with fixed IDs
INSERT INTO account (id, email, data, restricted)
VALUES
  (
    '00000000-0000-0000-0000-000000000001',
    'sammy@slugmart.com',
    jsonb_build_object(
      'password', crypt('sammyslug', 'hello'),
      'name', jsonb_build_object('first', 'Sammy', 'last', 'Slug'),
      'roles', jsonb_build_array('Shopper','Vendor','Admin'),
      'profile', jsonb_build_object('username', 'sammyslug', 'bio', 'I love shopping.')
    ),
    false
  ),
  (
    '00000000-0000-0000-0000-000000000002',
    'test@example.com',
    jsonb_build_object(
      'password', crypt('password', 'hello'),
      'name', jsonb_build_object('first', 'John', 'last', 'Doe'),
      'roles', jsonb_build_array('admin'),
      'profile', jsonb_build_object('username', 'johndoe', 'bio', 'Administrator account.')
    ),
    false
  );

-- Seed listings (using fixed IDs)
INSERT INTO listing (id, owner_id, data)
VALUES
  (
    '00000000-0000-0000-0000-000000000010',
    '00000000-0000-0000-0000-000000000001',
    jsonb_build_object(
      'brand', 'TestBrand',
      'name', 'TestName',
      'description', 'A test description',
      'imageUrls', ARRAY['http://example.com/image.jpg']
    )
  )
ON CONFLICT (id) DO NOTHING;

INSERT INTO listing (id, owner_id, data)
VALUES
  (
    '00000000-0000-0000-0000-000000000011',
    '00000000-0000-0000-0000-000000000001',
    jsonb_build_object(
      'brand', 'TestBrand2',
      'name', 'AnotherItem',
      'description', 'Another test description',
      'imageUrls', ARRAY['http://example.com/image2.jpg']
    )
  )
ON CONFLICT (id) DO NOTHING;

-- Seed a message
INSERT INTO message (id, item_owner_id, sender_id, data)
VALUES (
  '00000000-0000-0000-0000-000000000100',
  '00000000-0000-0000-0000-000000000010',
  '00000000-0000-0000-0000-000000000002',
  jsonb_build_object('content', 'Initial test message')
)
ON CONFLICT (id) DO NOTHING;

-- Seed orders
INSERT INTO orders (id, buyer_id, seller_id, shipping_status, item_id, data)
VALUES
  (
    '11111111-1111-1111-1111-111111111111',
    '00000000-0000-0000-0000-000000000002',
    '00000000-0000-0000-0000-000000000001',
    'PENDING',
    '00000000-0000-0000-0000-000000000010',
    jsonb_build_object('notes', 'Sample seeded order #1')
  )
ON CONFLICT (id) DO NOTHING;

INSERT INTO orders (id, buyer_id, seller_id, shipping_status, item_id, data)
VALUES
  (
    '22222222-2222-2222-2222-222222222222',
    '00000000-0000-0000-0000-000000000002',
    '00000000-0000-0000-0000-000000000001',
    'SHIPPED',
    '00000000-0000-0000-0000-000000000011',
    jsonb_build_object('notes', 'Sample seeded order #2')
  )
ON CONFLICT (id) DO NOTHING;

================
File: tests/fixtures/schema.sql
================
-- tests/fixtures/schema.sql
-- Production schema for all tables

CREATE EXTENSION IF NOT EXISTS pgcrypto;

DROP TABLE IF EXISTS orders CASCADE;
DROP TABLE IF EXISTS message CASCADE;
DROP TABLE IF EXISTS listing CASCADE;
DROP TABLE IF EXISTS account CASCADE;

-- Account table
CREATE TABLE account (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text UNIQUE NOT NULL,
  data jsonb NOT NULL,
  restricted boolean NOT NULL DEFAULT false
);

-- Listing table
CREATE TABLE listing (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id uuid NOT NULL,
  data jsonb NOT NULL
);

-- Message table
CREATE TABLE message (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  item_owner_id uuid NOT NULL,
  sender_id uuid NOT NULL,
  data jsonb NOT NULL
);

-- Orders table
CREATE TABLE orders (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  buyer_id uuid NOT NULL,
  seller_id uuid NOT NULL,
  shipping_status text NOT NULL DEFAULT 'pending',
  item_id uuid NOT NULL,
  data jsonb,
  CONSTRAINT fk_order_buyer
    FOREIGN KEY (buyer_id)
    REFERENCES account (id)
    ON DELETE CASCADE,
  CONSTRAINT fk_order_seller
    FOREIGN KEY (seller_id)
    REFERENCES account (id)
    ON DELETE CASCADE,
  CONSTRAINT fk_order_item
    FOREIGN KEY (item_id)
    REFERENCES listing (id)
);

================
File: tests/dbTest.ts
================
// tests/dbTest.ts

import { Pool } from "pg";
import dotenv from "dotenv";
import * as fs from "fs";
import * as path from "path";

dotenv.config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL, // points to your test DB
});

export async function resetGlobal(): Promise<void> {
  const fixturesPath = path.join(__dirname, "fixtures");
  const schemaFile = path.join(fixturesPath, "schema.sql");
  const dataFile = path.join(fixturesPath, "data.sql");

  if (fs.existsSync(schemaFile)) {
    const schema = fs.readFileSync(schemaFile, "utf8");
    await pool.query(schema);
    console.log(`Executed global schema file: ${schemaFile}`);
  } else {
    throw new Error(`Global schema file not found at: ${schemaFile}`);
  }

  if (fs.existsSync(dataFile)) {
    const data = fs.readFileSync(dataFile, "utf8");
    await pool.query(data);
    console.log(`Executed global data file: ${dataFile}`);
  } else {
    throw new Error(`Global data file not found at: ${dataFile}`);
  }
}

export function shutdown(done: Function): void {
  pool.end(() => {
    done();
  });
}

================
File: babel.config.js
================
// microservices/auth/babel.config.js
module.exports = {
    presets: [
      ['@babel/preset-env', { targets: { node: 'current' } }], 
      '@babel/preset-typescript'
    ],
  };

================
File: db.ts
================
import { Pool } from 'pg';
import dotenv from 'dotenv';
dotenv.config();

console.log(process.env.DATABASE_URL);

export const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
  });

================
File: index.ts
================
// src/index.ts
import dotenv from "dotenv";
import express from "express";
import helmet from "helmet";
import { createHandler } from "graphql-http/lib/use/express";
import { Pool } from "pg";
import "reflect-metadata";
import { buildSchema, AuthChecker } from "type-graphql";
import * as jwt from "jsonwebtoken";
import { Container } from "typedi";
dotenv.config();

import { AccountResolver } from "./src/account/graphql/resolver";
import { AuthResolver } from "./src/auth/graphql/resolver";
import { ListingResolver } from "./src/listing/graphql/resolver";
import { MessageResolver } from "./src/message/graphql/resolver";
import { OrderResolver } from "./src/orders/graphql/resolver";
import { S3Resolver } from "./src/s3/graphql/resolver";

// Use a single database pool instance
export const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

/**
 * Global auth checker for TypeGraphQL.
 * Public operations like login and makeAccount bypass authentication.
 */
const customAuthChecker: AuthChecker<any> = ({ context }, roles) => {
  if (context.req.body && typeof context.req.body.query === "string") {
    if (/(\blogin\b)|(\bmakeAccount\b)/i.test(context.req.body.query)) {
      return true;
    }
  }
  const authHeader = context.req.headers.authorization;
  if (!authHeader) {
    return false;
  }
  const token = authHeader.split(" ")[1];
  try {
    const decoded = jwt.verify(token, process.env.MASTER_SECRET as string) as { id: string };
    context.userId = decoded.id;
    return true;
  } catch (err) {
    return false;
  }
};

async function createSchema() {
  return await buildSchema({
    resolvers: [AuthResolver, AccountResolver, ListingResolver, MessageResolver, OrderResolver, S3Resolver],
    authChecker: customAuthChecker,
    container: Container,
  });
}

export async function createApp() {
  // Test database connection
  const client = await pool.connect();
  const res = await client.query("SELECT NOW()");
  client.release();
  console.log("Connected to database, current time:", res.rows[0].now);

  // Build the schema
  const schema = await createSchema();

  const app = express();

  app.use(helmet());
  app.use(express.json());

  // Mount the GraphQL endpoint (auth is handled via TypeGraphQL)
  app.all(
    "/graphql",
    createHandler({
      schema,
      context: (req) => ({ req }),
    })
  );

  return app;
}

if (require.main === module) {
  createApp()
    .then((app) => {
      app.listen(4000, () => {
        console.log("Running a GraphQL API server at http://localhost:4000/graphql");
      });
    })
    .catch((err) => {
      console.error("Failed to start server", err);
    });
}

================
File: jest.config.js
================
// microservices/auth/jest.config.js
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    rootDir: './',
    //testMatch: ['<rootDir>/src/test/*.test.ts'],
    moduleFileExtensions: ['ts', 'js'],
    transform: {
        '^.+\\.(ts|tsx)$': [
            'ts-jest',
            { 
                tsconfig: 'tsconfig.json'
            }
        ],
        // This line allows Babel to transform ESM in node_modules
        '^.+\\.(js|mjs)$': 'babel-jest',
    },
    testPathIgnorePatterns: [
        "/node_modules/",
        "/dist/"
      ],
    transformIgnorePatterns: [
        // Override default to allow graphql-request to be transformed
        'node_modules/(?!graphql-request)'
    ],

};

================
File: package.json
================
{
  "name": "vintain-backend",
  "version": "1.0.0",
  "description": "",
  "main": "dist/index.js",
  "scripts": {
    "dev": "ts-node src/index.ts",
    "build": "tsc",
    "start": "tsc && node dist/index.js",
    "test": "npm run test:auth && npm run test:account && npm run test:listing && npm run test:message && npm run test:orders",
    "test:auth": "jest --config jest.config.js --testPathPattern='tests/domains/auth/' --runInBand",
    "test:account": "jest --config jest.config.js --testPathPattern='tests/domains/account/' --runInBand",
    "test:listing": "jest --config jest.config.js --testPathPattern='tests/domains/listing/' --runInBand",
    "test:message": "jest --config jest.config.js --testPathPattern='tests/domains/message/' --runInBand",
    "test:orders": "jest --config jest.config.js --testPathPattern='tests/domains/orders/' --runInBand"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "class-validator": "^0.14.1",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "graphql": "^16.10.0",
    "graphql-http": "^1.22.3",
    "graphql-request": "^7.1.2",
    "helmet": "^8.0.0",
    "http": "^0.0.1-security",
    "jsonwebtoken": "^9.0.2",
    "pg": "^8.13.1",
    "reflect-metadata": "^0.2.2",
    "supertest": "^7.0.0",
    "type-graphql": "^2.0.0-rc.2",
    "typedi": "^0.10.0"
  },
  "devDependencies": {
    "@babel/preset-env": "^7.26.0",
    "@babel/preset-typescript": "^7.26.0",
    "@types/express": "^5.0.0",
    "@types/graphql": "^14.5.0",
    "@types/jest": "^29.5.14",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/node": "^22.10.2",
    "@types/pg": "^8.11.10",
    "@types/supertest": "^6.0.2",
    "jest": "^29.7.0",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.7.2"
  }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2021",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,

    // For NestJS/TypeGraphQL/other decorators
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,

    // Keep your life simpler
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,

    // Where compiled JS goes
    "outDir": "dist",

    // The root where TS looks for source .ts files
    // '.' means "the same directory as tsconfig.json"
    "rootDir": "."
  },

  // Tell TypeScript which files/folders to include
  // Here we say "any .ts file in any subfolder"
  "include": [
    "**/*.ts"
  ],

  // Usually exclude node_modules and the dist build folder
  "exclude": [
    "node_modules",
    "dist"
  ]
}

================
File: Backend/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2021",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,

    // For NestJS/TypeGraphQL/other decorators
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,

    // Keep your life simpler
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,

    // Where compiled JS goes
    "outDir": "dist",

    // The root where TS looks for source .ts files
    // '.' means "the same directory as tsconfig.json"
    "rootDir": "."
  },

  // Tell TypeScript which files/folders to include
  // Here we say "any .ts file in any subfolder"
  "include": [
    "**/*.ts"
  ],

  // Usually exclude node_modules and the dist build folder
  "exclude": [
    "node_modules",
    "dist"
  ]
}

================
File: vintainApp/app/(tabs)/_layout.tsx
================
import { Tabs } from "expo-router";
import React from "react";
import { Platform, StyleSheet } from "react-native";

import { HapticTab } from "@/components/HapticTab";
import { IconSymbol } from "@/components/ui/IconSymbol";
import TabBarBackground from "@/components/ui/TabBarBackground";
import { Colors } from "@/constants/Colors";
import { useColorScheme } from "@/hooks/useColorScheme";

export default function TabLayout() {
  const colorScheme = useColorScheme();
  const currentColors = Colors[colorScheme ?? "light"];

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: currentColors.tabIconSelected,
        headerShown: false,
        tabBarButton: HapticTab,
        tabBarBackground: TabBarBackground,
        tabBarStyle: [
          styles.tabBar,
          Platform.select({
            ios: {
              position: "absolute",
              backgroundColor: currentColors.background,
              borderTopColor: currentColors.border,
              borderTopWidth: 1,
            },
            default: {},
          }),
        ],
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: "Home",
          tabBarIcon: ({ color }) => (
            <IconSymbol size={28} name="house.fill" color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="createListing"
        options={{
          title: "New Listing",
          // Use an icon (we’ll add "plus" to our IconSymbol mapping below)
          tabBarIcon: ({ color }) => (
            <IconSymbol size={28} name="plus" color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="profile"
        options={{
          title: "Profile",
          tabBarIcon: ({ color }) => (
            <IconSymbol size={28} name="person.circle.fill" color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

const styles = StyleSheet.create({
  tabBar: {
    height: 60,
    paddingBottom: 5,
    paddingTop: 5,
  },
});

================
File: vintainApp/app/(tabs)/createListing.tsx
================
// vintainApp/app/(tabs)/createListing.tsx
import React, { useState, useContext } from 'react';
import { SafeAreaView, Text, TextInput, Button, StyleSheet, Alert, Image, ScrollView, TouchableOpacity } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import { useRouter } from 'expo-router';
import { createListing, generateUploadUrl } from '../../src/apiService';
import { AuthContext } from '../../context/authContext';

export default function CreateListingScreen() {
  const router = useRouter();
  const { user } = useContext(AuthContext);

  const [brand, setBrand] = useState('');
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [imageUrls, setImageUrls] = useState<string[]>([]);
  const [uploading, setUploading] = useState(false);

  async function pickListingImage() {
    const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (!permissionResult.granted) {
      Alert.alert("Permission required", "Permission to access media library is required.");
      return;
    }
const pickerResult = await ImagePicker.launchImageLibraryAsync({
  allowsEditing: true,
  quality: 0.8,
});
if (!pickerResult.canceled) {
  // TypeScript now expects you to use the assets array
  const asset = pickerResult.assets[0];
  if (asset && asset.uri) {
    uploadListingImage(asset.uri);
  }
}
  }

  async function uploadListingImage(uri: string) {
    try {
      setUploading(true);
      const fileName = uri.split('/').pop() || `listing_${Date.now()}.jpg`;
      const contentType = 'image/jpeg';
      // Use folder "listing" for listing images.
      const { preSignedUrl, fileUrl } = await generateUploadUrl(fileName, contentType, 'listing');
      const response = await fetch(uri);
      const blob = await response.blob();
      const uploadResult = await fetch(preSignedUrl, {
        method: 'PUT',
        headers: { 'Content-Type': contentType },
        body: blob,
      });
      if (!uploadResult.ok) {
        throw new Error("Image upload failed.");
      }
      setImageUrls(prev => [...prev, fileUrl]);
      Alert.alert("Success", "Image added!");
    } catch (error: any) {
      Alert.alert("Error", error.message || "Failed to upload image");
      console.log("this is the error", error);
    } finally {
      setUploading(false);
    }
  }

  async function handleSubmit() {
    if (!user || !user.id) {
      Alert.alert("Error", "User not logged in.");
      return;
    }
    if (!brand || !name || !description) {
      Alert.alert("Error", "Brand, Name, and Description are required.");
      return;
    }
    try {
      // Pass the imageUrls array to the backend (createListing expects it)
      const listing = await createListing(user.id, brand, name, description, imageUrls);
      Alert.alert("Success", "Listing created!");
      router.push(`/listingDetail?listingId=${listing.id}`);
    } catch (err: any) {
      Alert.alert("Error", err.message || "Failed to create listing");
    }
  }

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView>
        <Text style={styles.header}>Create New Listing</Text>
        <TextInput 
          style={styles.input}
          placeholder="Brand"
          value={brand}
          onChangeText={setBrand}
        />
        <TextInput 
          style={styles.input}
          placeholder="Name"
          value={name}
          onChangeText={setName}
        />
        <TextInput 
          style={[styles.input, styles.multiline]}
          placeholder="Description"
          value={description}
          onChangeText={setDescription}
          multiline
        />
        <Button title="Add Photo" onPress={pickListingImage} disabled={uploading} color="#8d6e63" />
        <ScrollView horizontal style={styles.imagePreviewContainer}>
          {imageUrls.map((url, idx) => (
            <Image key={idx} source={{ uri: url }} style={styles.imagePreview} />
          ))}
        </ScrollView>
        <Button title="Create Listing" onPress={handleSubmit} color="#8d6e63" />
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16, backgroundColor: '#fff8e1' },
  header: { fontSize: 24, fontWeight: 'bold', marginBottom: 16, textAlign: 'center', color: '#3e2723' },
  input: { borderWidth: 1, borderColor: '#8d6e63', borderRadius: 8, padding: 10, marginBottom: 12, backgroundColor: '#fff', color: '#3e2723' },
  multiline: { height: 100, textAlignVertical: 'top' },
  imagePreviewContainer: { marginVertical: 10 },
  imagePreview: { width: 100, height: 100, marginRight: 10, borderRadius: 8 },
});

================
File: vintainApp/app/(tabs)/index.tsx
================
// vintainApp/app/(tabs)/index.tsx
import React, { useEffect, useState } from 'react';
import {
  SafeAreaView,
  Text,
  Button,
  TextInput,
  FlatList,
  StyleSheet,
  TouchableOpacity,
} from 'react-native';
import { useRouter } from 'expo-router';
import { fetchAllListings, searchListings } from '../../src/apiService';

interface Listing {
  id: string;
  brand: string;
  name: string;
  description: string;
  imageUrls: string[];
}

export default function ListingListScreen() {
  const router = useRouter();

  const [listings, setListings] = useState<Listing[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const [page, setPage] = useState(1);
  const [searchTerm, setSearchTerm] = useState('');
  const [isSearching, setIsSearching] = useState(false);

  const pageSize = 5;

  useEffect(() => {
    loadListings(page);
  }, [page]);

  async function loadListings(newPage: number) {
    try {
      let data;
      if (isSearching && searchTerm.trim().length > 0) {
        data = await searchListings(searchTerm, newPage, pageSize);
      } else {
        data = await fetchAllListings(newPage, pageSize);
      }
      setListings(data.listings);
      setTotalCount(data.totalCount);
    } catch (err) {
      console.error('Failed to load listings:', err);
    }
  }

  async function onSearch() {
    setIsSearching(true);
    setPage(1);
    try {
      const data = await searchListings(searchTerm, 1, pageSize);
      setListings(data.listings);
      setTotalCount(data.totalCount);
    } catch (err) {
      console.error('Search error:', err);
    }
  }

  function onClearSearch() {
    setSearchTerm('');
    setIsSearching(false);
    setPage(1);
  }

  function onNextPage() {
    if ((page * pageSize) < totalCount) {
      setPage(prev => prev + 1);
    }
  }

  function onPrevPage() {
    if (page > 1) {
      setPage(prev => prev - 1);
    }
  }

  function renderItem({ item }: { item: Listing }) {
    return (
      <TouchableOpacity
        style={styles.listItem}
        onPress={() => router.push({
          pathname: '/listingDetail',
          params: { listingId: item.id },
        })}
      >
        <Text style={styles.listItemTitle}>
          {item.brand} - {item.name}
        </Text>
        <Text numberOfLines={2} style={styles.listItemDescription}>
          {item.description}
        </Text>
      </TouchableOpacity>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <Text style={styles.title}>Vintage Listings</Text>

      <SafeAreaView style={styles.searchRow}>
        <TextInput
          style={styles.searchInput}
          placeholder="Search brand/description..."
          placeholderTextColor="#8d6e63"
          value={searchTerm}
          onChangeText={setSearchTerm}
        />
        <Button title="Search" onPress={onSearch} color="#8d6e63" />
        <Button title="Clear" onPress={onClearSearch} color="#a1887f" />
      </SafeAreaView>

      <FlatList
        data={listings}
        keyExtractor={(item) => item.id}
        renderItem={renderItem}
      />

      <SafeAreaView style={styles.paginationRow}>
        <Button title="Prev" onPress={onPrevPage} disabled={page === 1} color="#8d6e63" />
        <Text style={styles.pageText}>Page {page}</Text>
        <Button title="Next" onPress={onNextPage} disabled={(page * pageSize) >= totalCount} color="#8d6e63" />
      </SafeAreaView>

      <Text style={styles.totalText}>Total Listings: {totalCount}</Text>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: '#fff8e1',
  },
  title: {
    fontSize: 26,
    textAlign: 'center',
    marginBottom: 16,
    fontFamily: 'SpaceMono',
    color: '#3e2723',
  },
  searchRow: {
    flexDirection: 'row',
    marginBottom: 12,
    alignItems: 'center',
  },
  searchInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#8d6e63',
    borderRadius: 8,
    padding: 8,
    marginRight: 4,
    color: '#3e2723',
    fontFamily: 'SpaceMono',
    backgroundColor: '#fff',
  },
  listItem: {
    backgroundColor: '#f7f1e3',
    marginVertical: 6,
    padding: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#d7ccc8',
  },
  listItemTitle: {
    fontWeight: 'bold',
    marginBottom: 4,
    fontSize: 18,
    color: '#3e2723',
    fontFamily: 'SpaceMono',
  },
  listItemDescription: {
    fontSize: 14,
    color: '#5d4037',
    fontFamily: 'SpaceMono',
  },
  paginationRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
    alignItems: 'center',
  },
  pageText: {
    fontFamily: 'SpaceMono',
    fontSize: 16,
    color: '#3e2723',
  },
  totalText: {
    textAlign: 'center',
    marginTop: 8,
    fontFamily: 'SpaceMono',
    color: '#3e2723',
  },
});

================
File: vintainApp/app/(tabs)/profile.tsx
================
// vintainApp/app/(tabs)/profile.tsx
import React, { useContext, useEffect, useState } from "react";
import {
  SafeAreaView,
  Text,
  StyleSheet,
  ActivityIndicator,
  Button,
} from "react-native";
import { AuthContext } from "../../context/authContext";
import { fetchMyProfile } from "../../src/apiService";
import { useRouter } from "expo-router";

export default function ProfileScreen() {
  const router = useRouter();
  const { user, signOut } = useContext(AuthContext);
  const [profile, setProfile] = useState<{
    id: string;
    name: { first: string; last: string };
    profile: { username: string; bio?: string | null };
  } | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (user?.id) {
      loadProfile(user.id);
    } else {
      setLoading(false);
    }
  }, [user]);

  async function loadProfile(id: string) {
    try {
      const data = await fetchMyProfile(id);
      setProfile(data);
    } catch (err) {
      console.error("Failed to fetch profile:", err);
    } finally {
      setLoading(false);
    }
  }

  function handleSignOut() {
    signOut().catch((err) => {
      console.error("Failed to sign out", err);
    });
  }

  if (loading) {
    return (
      <SafeAreaView style={styles.container}>
        <ActivityIndicator color="#8d6e63" />
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      {profile ? (
        <>
          <Text style={styles.title}>
            {profile.name.first} {profile.name.last}
          </Text>
          <Text style={styles.subtitle}>@{profile.profile.username}</Text>
          <Text style={styles.bio}>
            {profile.profile.bio != null
              ? profile.profile.bio
              : "No bio available."}
          </Text>
        </>
      ) : (
        <>
          <Text style={styles.message}>No profile found.</Text>
        </>
      )}
      <Button
        title="Edit Profile"
        onPress={() => router.push("/editProfile")}
        color="#8d6e63"
      />
      <Button title="Sign Out" onPress={handleSignOut} color="#8d6e63" />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16, backgroundColor: "#fff8e1", justifyContent: "center", alignItems: "center" },
  title: { fontSize: 28, fontWeight: "bold", marginBottom: 8, color: "#3e2723", fontFamily: 'SpaceMono' },
  subtitle: { fontSize: 20, color: "#5d4037", marginBottom: 12, fontFamily: 'SpaceMono' },
  bio: { fontSize: 16, marginBottom: 16, color: "#3e2723", fontFamily: 'SpaceMono', textAlign: "center" },
  message: { fontSize: 16, marginBottom: 16, color: "#3e2723", fontFamily: 'SpaceMono' },
});

================
File: vintainApp/app/_layout.tsx
================
// app/_layout.tsx
import { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';
import { useFonts } from 'expo-font';
import { Stack } from 'expo-router';
import * as SplashScreen from 'expo-splash-screen';
import { StatusBar } from 'expo-status-bar';
import { useEffect, useContext } from 'react';
import 'react-native-reanimated';
import { useColorScheme } from '@/hooks/useColorScheme';
import { AuthProvider, AuthContext } from '../context/authContext';
import AuthScreen from './auth';

// *** Import our React Query setup to enable online and focus management ***
import '../src/reactQuerySetup';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

// Create a React Query client
const queryClient = new QueryClient();

SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const colorScheme = useColorScheme();
  const [loaded] = useFonts({
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  useEffect(() => {
    if (loaded) {
      SplashScreen.hideAsync();
    }
  }, [loaded]);

  if (!loaded) {
    return null;
  }

  return (
    <AuthProvider>
      <QueryClientProvider client={queryClient}>
        <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>
          <AuthOrStack />
          <StatusBar style="auto" />
        </ThemeProvider>
      </QueryClientProvider>
    </AuthProvider>
  );
}

function AuthOrStack() {
  const { token, loading } = useContext(AuthContext);

  if (loading) {
    return null;
  }

  if (!token) {
    return <AuthScreen />;
  }

  return (
    <Stack>
      <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
      <Stack.Screen name="+not-found" />
      <Stack.Screen
        name="listingDetail"
        options={{
          headerTitle: '',
          headerBackTitle: '',
          headerTransparent: true,
          headerBackButtonMenuEnabled: false,
        }}
      />
    </Stack>
  );
}

================
File: vintainApp/app/+not-found.tsx
================
import { Link, Stack } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import React from 'react';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <ThemedView style={styles.container}>
        <ThemedText type="title">This screen doesn't exist.</ThemedText>
        <Link href="/" style={styles.link}>
          <ThemedText type="link">Go to home screen!</ThemedText>
        </Link>
      </ThemedView>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
    backgroundColor: '#fff8e1',
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});

================
File: vintainApp/app/auth.tsx
================
// vintainApp/app/auth.tsx
import React, { useContext, useState } from "react";
import {
  SafeAreaView,
  KeyboardAvoidingView,
  View,
  Text,
  TextInput,
  Button,
  StyleSheet,
  Alert,
  TouchableOpacity,
  Platform,
} from "react-native";
import { AuthContext } from "../context/authContext";
import { signIn as apiSignIn, signUp as apiSignUp } from "../src/apiService";

export default function AuthScreen() {
  const { signIn } = useContext(AuthContext);

  const [isSignUp, setIsSignUp] = useState(false);

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [username, setUsername] = useState("");

  const defaultRoles = ["User"];

  async function handleSubmit() {
    if (isSignUp) {
      try {
        const newAccount = await apiSignUp(
          email,
          password,
          firstName,
          lastName,
          defaultRoles,
          username
        );
        Alert.alert("Success", `Account created for ${newAccount.email}`);
        setIsSignUp(false);
      } catch (err: any) {
        Alert.alert("Error", err.message || "Failed to create account");
      }
    } else {
      try {
        const data = await apiSignIn(email, password);
        Alert.alert("Welcome", `Hello, ${data.name.first}!`);
        await signIn(data.accessToken, data);
      } catch (err: any) {
        Alert.alert("Error", err.message || "Failed to sign in");
      }
    }
  }

  function toggleMode() {
    setIsSignUp(!isSignUp);
  }

  return (
    <SafeAreaView style={styles.safeArea}>
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      >
        <Text style={styles.header}>
          {isSignUp ? "Create Account" : "Sign In"}
        </Text>

        <TextInput
          style={styles.input}
          placeholder="Email"
          placeholderTextColor="#8d6e63"
          autoCapitalize="none"
          value={email}
          onChangeText={setEmail}
        />

        <TextInput
          style={styles.input}
          placeholder="Password"
          placeholderTextColor="#8d6e63"
          secureTextEntry
          value={password}
          autoCapitalize="none"
          onChangeText={setPassword}
        />

        {isSignUp && (
          <>
            <TextInput
              style={styles.input}
              placeholder="First Name"
              placeholderTextColor="#8d6e63"
              value={firstName}
              autoCapitalize="none"
              onChangeText={setFirstName}
            />
            <TextInput
              style={styles.input}
              placeholder="Last Name"
              placeholderTextColor="#8d6e63"
              value={lastName}
              autoCapitalize="none"
              onChangeText={setLastName}
            />
            <TextInput
              style={styles.input}
              placeholder="Username"
              placeholderTextColor="#8d6e63"
              value={username}
              autoCapitalize="none"
              onChangeText={setUsername}
            />
          </>
        )}

        <Button title={isSignUp ? "Sign Up" : "Sign In"} onPress={handleSubmit} color="#8d6e63" />

        <TouchableOpacity onPress={toggleMode} style={styles.toggleBtn}>
          <Text style={styles.toggleText}>
            {isSignUp
              ? "Already have an account? Sign in"
              : "Don't have an account? Sign up"}
          </Text>
        </TouchableOpacity>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: { flex: 1, backgroundColor: '#fff8e1' },
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: '#fff8e1',
    justifyContent: "center",
  },
  header: {
    fontSize: 28,
    marginBottom: 16,
    textAlign: "center",
    fontFamily: 'SpaceMono',
    color: '#3e2723',
  },
  input: {
    borderWidth: 1,
    borderColor: "#8d6e63",
    marginBottom: 12,
    padding: 10,
    borderRadius: 8,
    color: '#3e2723',
    fontFamily: 'SpaceMono',
    backgroundColor: '#fff',
  },
  toggleBtn: {
    marginTop: 12,
    alignItems: "center",
  },
  toggleText: {
    color: "#8d6e63",
    fontSize: 14,
    textDecorationLine: "underline",
    fontFamily: 'SpaceMono',
  },
});

================
File: vintainApp/app/editProfile.tsx
================
// vintainApp/app/editProfile.tsx
import React, { useState, useContext } from 'react';
import {
  SafeAreaView,
  KeyboardAvoidingView,
  View,
  Text,
  TextInput,
  Button,
  Alert,
  StyleSheet,
  Platform,
  Image
} from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import { useRouter } from 'expo-router';
import { updateProfile, generateUploadUrl } from '../src/apiService';
import { AuthContext } from '../context/authContext';

export default function EditProfileScreen() {
  const { user } = useContext(AuthContext);
  const userId = user?.id;
  const router = useRouter();

  const [username, setUsername] = useState(user?.profile?.username || '');
  const [bio, setBio] = useState(user?.profile?.bio || '');
  const [profilePicUrl, setProfilePicUrl] = useState<string | null>(user?.profile?.profilePicture || null);
  const [uploading, setUploading] = useState(false);

  async function pickImage() {
    const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (permissionResult.granted === false) {
      Alert.alert('Permission required', 'Permission to access camera roll is required!');
      return;
    }
    const pickerResult = await ImagePicker.launchImageLibraryAsync({
      allowsEditing: true,
      quality: 0.8,
    });
    if (!pickerResult.canceled) {
        // TypeScript now expects you to use the assets array
        const asset = pickerResult.assets[0];
        if (asset && asset.uri) {
          uploadProfilePicture(asset.uri);
        }
    }
  }

  async function uploadProfilePicture(uri: string) {
    try {
      setUploading(true);
      // Extract filename and determine MIME type.
      // In a production app, you might use a library (or inspect the file extension)
      // Here, we assume a JPEG image.
      const fileName = uri.split('/').pop() || `profile_${Date.now()}.jpg`;
      const contentType = 'image/jpeg';

      // Call our API helper to get a pre-signed URL (using folder "profile")
      const { preSignedUrl, fileUrl } = await generateUploadUrl(fileName, contentType, 'profile');

      // Read the file as a blob
      const response = await fetch(uri);
      const blob = await response.blob();

      // Upload the file to S3 using the pre-signed URL with PUT
      const uploadResult = await fetch(preSignedUrl, {
        method: 'PUT',
        headers: {
          'Content-Type': contentType,
        },
        body: blob,
      });
      if (!uploadResult.ok) {
        throw new Error('Upload failed.');
      }
      // Set the profile picture URL locally so it can be shown immediately.
      setProfilePicUrl(fileUrl);
      Alert.alert('Success', 'Profile picture uploaded!');
    } catch (error: any) {
      Alert.alert('Error', error.message || 'Failed to upload profile picture');
    } finally {
      setUploading(false);
    }
  }

  async function handleSubmit() {
    if (!userId) {
      Alert.alert("Error", "User ID not found.");
      return;
    }
    try {
      // Pass the profilePicUrl if available
      const success = await updateProfile(userId, username, bio, profilePicUrl || undefined);
      if (success) {
        Alert.alert("Success", "Profile updated successfully!");
        router.back();
      } else {
        Alert.alert("Error", "Profile update failed.");
      }
    } catch (error: any) {
      Alert.alert("Error", error.message || "Failed to update profile");
    }
  }

  return (
    <SafeAreaView style={styles.safeArea}>
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      >
        <Text style={styles.header}>Edit Profile</Text>
        {profilePicUrl ? (
          <Image source={{ uri: profilePicUrl }} style={styles.profilePic} />
        ) : (
          <View style={[styles.profilePic, styles.profilePicPlaceholder]}>
            <Text style={styles.placeholderText}>No Photo</Text>
          </View>
        )}
        <Button title="Select Profile Picture" onPress={pickImage} disabled={uploading} color="#8d6e63" />
        <TextInput
          style={styles.input}
          placeholder="Username"
          value={username}
          onChangeText={setUsername}
        />
        <TextInput
          style={[styles.input, styles.multiline]}
          placeholder="Bio"
          value={bio}
          onChangeText={setBio}
          multiline
        />
        <Button title="Save Changes" onPress={handleSubmit} color="#8d6e63" />
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: { flex: 1, backgroundColor: '#fff8e1' },
  container: { flex: 1, padding: 16, justifyContent: 'center', alignItems: 'center' },
  header: { fontSize: 24, marginBottom: 16, textAlign: 'center' },
  input: { borderWidth: 1, borderColor: '#8d6e63', marginBottom: 12, padding: 8, borderRadius: 4, width: '100%' },
  multiline: { height: 80, textAlignVertical: 'top' },
  profilePic: { width: 120, height: 120, borderRadius: 60, marginBottom: 12 },
  profilePicPlaceholder: { backgroundColor: '#d7ccc8', justifyContent: 'center', alignItems: 'center' },
  placeholderText: { color: '#3e2723' },
});

================
File: vintainApp/app/listingDetail.tsx
================
import React, { useEffect, useState } from 'react';
import { useLocalSearchParams } from "expo-router";
import {
  View,
  Text,
  Image,
  StyleSheet,
  ScrollView,
  SafeAreaView,
} from 'react-native';
import { fetchListingById } from '../src/apiService';

export default function ListingDetail() {
  const { listingId } = useLocalSearchParams();
  const [listing, setListing] = useState<any>(null);

  useEffect(() => {
    if (listingId) {
      loadListing(listingId as string);
    }
  }, [listingId]);

  async function loadListing(id: string) {
    try {
      const data = await fetchListingById(id);
      setListing(data);
    } catch (err) {
      console.error('Failed to fetch listing detail:', err);
    }
  }

  if (!listing) {
    return (
      <SafeAreaView style={styles.container}>
        <Text style={styles.loadingText}>Loading listing details...</Text>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <Text style={styles.title}>{listing.brand} - {listing.name}</Text>
        <Text style={styles.subtitle}>Listing ID: {listing.id}</Text>
        <Text style={styles.description}>{listing.description}</Text>
        {listing.imageUrls?.map((url: string, idx: number) => (
          <Image key={idx} source={{ uri: url }} style={styles.image} />
        ))}
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff8e1',
  },
  scrollContent: {
    padding: 16,
  },
  title: { 
    fontSize: 24, 
    fontWeight: 'bold', 
    marginBottom: 8,
    color: '#3e2723',
    fontFamily: 'SpaceMono',
  },
  subtitle: { 
    fontSize: 14, 
    marginBottom: 8, 
    color: '#5d4037',
    fontFamily: 'SpaceMono',
  },
  description: { 
    fontSize: 16, 
    marginBottom: 12,
    color: '#3e2723',
    fontFamily: 'SpaceMono',
  },
  image: { 
    width: '100%', 
    height: 200, 
    resizeMode: 'cover', 
    marginBottom: 12,
    borderRadius: 8,
  },
  loadingText: {
    fontSize: 16,
    textAlign: 'center',
    marginTop: 20,
    color: '#3e2723',
    fontFamily: 'SpaceMono',
  },
});

================
File: vintainApp/components/__tests__/__snapshots__/ThemedText-test.tsx.snap
================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<Text
  style={
    [
      {
        "color": "#11181C",
      },
      {
        "fontSize": 16,
        "lineHeight": 24,
      },
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
    ]
  }
>
  Snapshot test!
</Text>
`;

================
File: vintainApp/components/__tests__/ThemedText-test.tsx
================
import * as React from 'react';
import renderer from 'react-test-renderer';

import { ThemedText } from '../ThemedText';

it(`renders correctly`, () => {
  const tree = renderer.create(<ThemedText>Snapshot test!</ThemedText>).toJSON();

  expect(tree).toMatchSnapshot();
});

================
File: vintainApp/components/ui/IconSymbol.ios.tsx
================
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        { width: size, height: size },
        style,
      ]}
    />
  );
}

================
File: vintainApp/components/ui/IconSymbol.tsx
================
// vintainApp/components/ui/IconSymbol.tsx
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight } from 'expo-symbols';
import React from 'react';
import { OpaqueColorValue, StyleProp, TextStyle } from 'react-native'; // Import TextStyle instead of ViewStyle

// Define a mapping for icon names to MaterialIcons names.
const MAPPING = {
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
  'plus': 'add',  // <-- added "plus" mapping
} as Partial<
  Record<
    import('expo-symbols').SymbolViewProps['name'],
    React.ComponentProps<typeof MaterialIcons>['name']
  >
>;

export type IconSymbolName = keyof typeof MAPPING;

export function IconSymbol({
  name,
  size = 24,
  color,
  style,  // Expect style to be a TextStyle style
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<TextStyle>;  // <-- use TextStyle here
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}

================
File: vintainApp/components/ui/TabBarBackground.ios.tsx
================
import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';
import { BlurView } from 'expo-blur';
import { StyleSheet } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function BlurTabBarBackground() {
  return (
    <BlurView
      tint="default"
      intensity={80}
      style={StyleSheet.absoluteFill}
    />
  );
}

export function useBottomTabOverflow() {
  const tabHeight = useBottomTabBarHeight();
  const { bottom } = useSafeAreaInsets();
  return tabHeight - bottom;
}

================
File: vintainApp/components/ui/TabBarBackground.tsx
================
// Shim for platforms without a blur view (web/Android)
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}

================
File: vintainApp/components/Collapsible.tsx
================
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity, View } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function Collapsible({ children, title }: PropsWithChildren<{ title: string }>) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView style={styles.container}>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />
        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <View style={styles.content}>{children}</View>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    marginVertical: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: '#d7ccc8',
    borderRadius: 8,
    backgroundColor: 'rgba(255,255,255,0.8)',
  },
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  content: {
    marginTop: 8,
    marginLeft: 24,
  },
});

================
File: vintainApp/components/ExternalLink.tsx
================
// components/ExternalLink.tsx
import { Link } from 'expo-router';
import { openBrowserAsync } from 'expo-web-browser';
import { type ComponentProps } from 'react';
import { Platform } from 'react-native';

// Define our own props: we want href to be any string.
type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href as any}  // <-- cast here so TypeScript won’t complain
      onPress={async (event) => {
        if (Platform.OS !== 'web') {
          event.preventDefault();
          await openBrowserAsync(href);
        }
      }}
    />
  );
}

================
File: vintainApp/components/HapticTab.tsx
================
// vintainApp/components/HapticTab.tsx
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import { Platform } from 'react-native';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (Platform.OS === 'ios') {
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}

================
File: vintainApp/components/HelloWave.tsx
================
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withRepeat,
  withSequence,
} from 'react-native-reanimated';

import { ThemedText } from '@/components/ThemedText';

export function HelloWave() {
  const rotationAnimation = useSharedValue(0);

  useEffect(() => {
    rotationAnimation.value = withRepeat(
      withSequence(withTiming(25, { duration: 150 }), withTiming(0, { duration: 150 })),
      4
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotationAnimation.value}deg` }],
  }));

  return (
    <Animated.View style={animatedStyle}>
      <ThemedText style={styles.text}>👋</ThemedText>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  text: {
    fontSize: 28,
    lineHeight: 32,
    marginTop: -6,
    textShadowColor: 'rgba(0,0,0,0.3)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
});

================
File: vintainApp/components/ParallaxScrollView.tsx
================
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollViewOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/ThemedView';
import { useBottomTabOverflow } from '@/components/ui/TabBarBackground';
import { useColorScheme } from '@/hooks/useColorScheme';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollViewOffset(scrollRef);
  const bottom = useBottomTabOverflow();
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <ThemedView style={styles.container}>
      <Animated.ScrollView
        ref={scrollRef}
        scrollEventThrottle={16}
        scrollIndicatorInsets={{ bottom }}
        contentContainerStyle={{ paddingBottom: bottom }}>
        <Animated.View
          style={[
            styles.header,
            { backgroundColor: headerBackgroundColor[colorScheme] },
            headerAnimatedStyle,
          ]}>
          {headerImage}
        </Animated.View>
        <ThemedView style={styles.content}>{children}</ThemedView>
      </Animated.ScrollView>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
    borderBottomLeftRadius: 20,
    borderBottomRightRadius: 20,
  },
  content: {
    flex: 1,
    padding: 24,
    gap: 16,
  },
});

================
File: vintainApp/components/ThemedText.tsx
================
import { Text, type TextProps, StyleSheet } from 'react-native';
import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color, fontFamily: 'SpaceMono' },
        type === 'default' && styles.default,
        type === 'title' && styles.title,
        type === 'defaultSemiBold' && styles.defaultSemiBold,
        type === 'subtitle' && styles.subtitle,
        type === 'link' && styles.link,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 36,
    textShadowColor: 'rgba(0, 0, 0, 0.2)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: '600',
    marginBottom: 4,
  },
  link: {
    fontSize: 16,
    color: '#8d6e63',
    textDecorationLine: 'underline',
  },
});

================
File: vintainApp/components/ThemedView.tsx
================
import { View, type ViewProps, StyleSheet } from 'react-native';
import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[styles.container, { backgroundColor }, style]} {...otherProps} />;
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

================
File: vintainApp/constants/Colors.ts
================
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

/**
 * Vintage earth tone color palette.
 */
export const Colors = {
  light: {
    text: "#3e2723",           // rich dark brown
    background: "#fff8e1",     // light creamy tone
    tint: "#8d6e63",           // soft taupe
    icon: "#6d4c41",           // deep brown
    tabIconDefault: "#6d4c41",
    tabIconSelected: "#8d6e63",
    border: "#d7ccc8",
  },
  dark: {
    text: "#d7ccc8",           // pale, light brownish grey
    background: "#4e342e",     // dark chocolate brown
    tint: "#bcaaa4",           // warm grey
    icon: "#a1887f",
    tabIconDefault: "#a1887f",
    tabIconSelected: "#bcaaa4",
    border: "#8d6e63",
  },
};

================
File: vintainApp/context/authContext.tsx
================
// vintainApp/context/authContext.tsx
import React, { createContext, useState, useEffect, ReactNode } from 'react';
import * as SecureStore from 'expo-secure-store';
// Import setAuthToken and fetchMyProfile from your API service.
import { setAuthToken, fetchMyProfile } from '../src/apiService';
// Import jwt-decode as a default import
import { jwtDecode } from "jwt-decode";

type AuthContextType = {
  token: string | null;
  user: any | null;
  loading: boolean;
  signIn: (token: string, user: any) => Promise<void>;
  signOut: () => Promise<void>;
};

export const AuthContext = createContext<AuthContextType>({
  token: null,
  user: null,
  loading: true,
  signIn: async () => undefined,
  signOut: async () => undefined,
});

type AuthProviderProps = {
  children: ReactNode;
};

export function AuthProvider({ children }: AuthProviderProps) {
  const [token, setTokenState] = useState<string | null>(null);
  const [user, setUser] = useState<any | null>(null);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    (async () => {
      try {
        // Attempt to load the saved token from SecureStore.
        const savedToken = await SecureStore.getItemAsync('token');
        if (savedToken) {
          setTokenState(savedToken);
          // Update our API service so all future requests include the token.
          setAuthToken(savedToken);
          // Decode the token to extract the user ID.
          const decoded: { id: string } = jwtDecode(savedToken);
          // Fetch the user profile using the decoded ID.
          const profile = await fetchMyProfile(decoded.id);
          setUser(profile);
        }
      } catch (err) {
        console.error('Error loading token or fetching profile:', err);
      } finally {
        setLoading(false);
      }
    })();
  }, []);

  async function signIn(newToken: string, userData: any) {
    try {
      await SecureStore.setItemAsync('token', newToken);
      setTokenState(newToken);
      setUser(userData);
      // Update our API service.
      setAuthToken(newToken);
    } catch (err) {
      console.error('Error saving token to SecureStore', err);
    }
  }

  async function signOut() {
    try {
      await SecureStore.deleteItemAsync('token');
      setTokenState(null);
      setUser(null);
      // Clear token in our API service.
      setAuthToken(null);
    } catch (err) {
      console.error('Error deleting token from SecureStore', err);
    }
  }

  const value: AuthContextType = {
    token,
    user,
    loading,
    signIn,
    signOut,
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

================
File: vintainApp/hooks/useColorScheme.ts
================
export { useColorScheme } from 'react-native';

================
File: vintainApp/hooks/useColorScheme.web.ts
================
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}

================
File: vintainApp/hooks/useThemeColor.ts
================
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}

================
File: vintainApp/scripts/reset-project.js
================
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const newDir = "app-example";
const newAppDir = "app";
const newDirPath = path.join(root, newDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const moveDirectories = async () => {
  try {
    // Create the app-example directory
    await fs.promises.mkdir(newDirPath, { recursive: true });
    console.log(`📁 /${newDir} directory created.`);

    // Move old directories to new app-example directory
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      const newDirPath = path.join(root, newDir, dir);
      if (fs.existsSync(oldDirPath)) {
        await fs.promises.rename(oldDirPath, newDirPath);
        console.log(`➡️ /${dir} moved to /${newDir}/${dir}.`);
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");

    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      "1. Run `npx expo start` to start a development server.\n2. Edit app/index.tsx to edit the main screen.\n3. Delete the /app-example directory when you're done referencing it."
    );
  } catch (error) {
    console.error(`Error during script execution: ${error}`);
  }
};

moveDirectories();

================
File: vintainApp/src/apiService.ts
================
// vintainApp/src/apiService.ts
const BASE_URL = "http://localhost:4000/graphql";

// A module-level variable to store the token:
let authToken: string | null = null;

// A function to update the token (you can call this from your AuthContext when a user signs in)
export function setAuthToken(token: string | null) {
  authToken = token;
}

async function graphQLFetch(query: string, variables: any = {}) {
  // Build headers, including Authorization if authToken exists.
  const headers: HeadersInit = {
    "Content-Type": "application/json",
    ...(authToken ? { "Authorization": `Bearer ${authToken}` } : {})
  };

  const res = await fetch(BASE_URL, {
    method: "POST",
    headers,
    body: JSON.stringify({ query, variables }),
  });
  const json = await res.json();
  if (json.errors) {
    console.log(json.errors[0].message);
    throw new Error(json.errors[0].message || "GraphQL Error");
  }
  return json.data;
}

export async function signUp(
  email: string,
  password: string,
  firstName: string,
  lastName: string,
  roles: string[],
  username: string
) {
  try {
    const query = `
      mutation($input: NewAccount!) {
        makeAccount(input: $input) {
          id
          email
        }
      }
    `;
    // Pass username in as well
    const variables = {
      input: {
        email,
        password,
        firstName,
        lastName,
        roles,
        username,  // required
      },
    };
    const data = await graphQLFetch(query, variables);
    return data.makeAccount;
  } catch (error) {
    console.log(error);
  }
}

export async function signIn(email: string, password: string) {
  // Use a mutation for the login operation
  const query = `
    mutation($creds: Credentials!) {
      login(input: $creds) {
        id
        name { first last }
        accessToken
      }
    }
  `;
  const variables = { creds: { email, password } };
  const data = await graphQLFetch(query, variables);
  return data.login;
}

export async function fetchAllListings(page = 1, pageSize = 10) {
  const query = `
    query($page: Int!, $pageSize: Int!) {
      allListings(page: $page, pageSize: $pageSize) {
        listings { id brand name description imageUrls }
        totalCount
      }
    }
  `;
  const data = await graphQLFetch(query, { page, pageSize });
  return data.allListings;
}

export async function searchListings(searchTerm: string, page = 1, pageSize = 10) {
  const query = `
    query($searchTerm: String!, $page: Int!, $pageSize: Int!) {
      searchListings(searchTerm: $searchTerm, page: $page, pageSize: $pageSize) {
        listings { id brand name description imageUrls }
        totalCount
      }
    }
  `;
  const data = await graphQLFetch(query, { searchTerm, page, pageSize });
  return data.searchListings;
}

export async function fetchListingById(id: string) {
  const query = `
    query($id: String!) {
      listing(id: $id) {
        id
        brand
        name
        description
        imageUrls
      }
    }
  `;
  const data = await graphQLFetch(query, { id });
  return data.listing;
}

export async function fetchMyProfile(id: string) {
  const query = `
    query($id: String!) {
      account(input: $id) {
        id
        name {
          first
          last
        }
        profile {
          username
          bio
        }
      }
    }
  `;
  const variables = { id };
  const data = await graphQLFetch(query, variables);
  return data.account;
}

export async function updateProfile(
    id: string,
    username?: string,
    bio?: string,
    profilePicture?: string
  ) {
    const query = `
      mutation UpdateProfile($id: String!, $username: String, $bio: String, $profilePicture: String) {
        updateProfile(id: $id, username: $username, bio: $bio, profilePicture: $profilePicture)
      }
    `;
    const variables = { id, username, bio, profilePicture };
    const data = await graphQLFetch(query, variables);
    return data.updateProfile; // should return true/false
  }


// Inside vintainApp/src/apiService.ts
export async function createListing(
    ownerId: string,
    brand: string,
    name: string,
    description: string,
    imageUrls: string[]
  ) {
    const query = `
      mutation CreateListing($input: NewListing!) {
        createListing(input: $input) {
          id
          ownerId
          brand
          name
          description
          imageUrls
        }
      }
    `;
    const variables = {
      input: { ownerId, brand, name, description, imageUrls },
    };
    const data = await graphQLFetch(query, variables);
    return data.createListing;
  }

  // vintainApp/src/apiService.ts

export async function generateUploadUrl(
    fileName: string,
    contentType: string,
    folder: string
  ) {

    console.log("apiservicegenerateuploadurl: ", fileName,contentType,folder);
    const query = `
      mutation GenerateUploadUrl($fileName: String!, $contentType: String!, $folder: String!) {
        generateUploadUrl(fileName: $fileName, contentType: $contentType, folder: $folder) {
          preSignedUrl
          fileUrl
        }
      }
    `;
    const variables = { fileName, contentType, folder };
    const data = await graphQLFetch(query, variables);
    return data.generateUploadUrl;
  }

================
File: vintainApp/src/reactQuerySetup.ts
================
// reactQuerySetup.ts
import NetInfo from '@react-native-community/netinfo';
import { onlineManager, focusManager } from '@tanstack/react-query';
import { AppState, Platform, AppStateStatus } from 'react-native';
// Option 1: using NetInfo from '@react-native-community/netinfo'
onlineManager.setEventListener((setOnline) => {
  return NetInfo.addEventListener((state) => {
    setOnline(!!state.isConnected);
  });
});

// Option 2: if you prefer expo-network, you could do:
// import * as Network from 'expo-network';
// onlineManager.setEventListener((setOnline) => {
//   return Network.addNetworkStateListener((state) => {
//     setOnline(state.isConnected);
//   });
// });

// Use AppState to update React Query focus (refetch on app focus)
function onAppStateChange(status: AppStateStatus) {
  if (Platform.OS !== 'web') {
    focusManager.setFocused(status === 'active');
  }
}

const subscription = AppState.addEventListener('change', onAppStateChange);
// (You may also want to remove the listener on unmount in a real app.)

================
File: vintainApp/.gitignore
================
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example

================
File: vintainApp/app.json
================
{
  "expo": {
    "name": "vintainApp",
    "slug": "vintainApp",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      }
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}

================
File: vintainApp/package.json
================
{
  "name": "vintainapp",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@react-native-community/netinfo": "^11.4.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "@react-navigation/stack": "^7.1.1",
    "@tanstack/react-query": "^5.66.0",
    "expo": "~52.0.23",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.5",
    "expo-font": "~13.0.3",
    "expo-haptics": "~14.0.1",
    "expo-image-picker": "^16.0.5",
    "expo-linking": "~7.0.5",
    "expo-router": "~4.0.17",
    "expo-secure-store": "~14.0.1",
    "expo-splash-screen": "~0.29.21",
    "expo-status-bar": "~2.0.1",
    "expo-symbols": "~0.2.2",
    "expo-system-ui": "~4.0.7",
    "expo-web-browser": "~14.0.2",
    "jwt-decode": "^4.0.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-native": "0.76.6",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-web": "~0.19.13",
    "react-native-webview": "13.12.5"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/jest": "^29.5.12",
    "@types/react": "~18.3.12",
    "@types/react-test-renderer": "^18.3.0",
    "jest": "~29.7.0",
    "jest-expo": "^52.0.0",
    "react-test-renderer": "18.3.1",
    "typescript": "^5.3.3"
  },
  "private": true
}

================
File: vintainApp/README.md
================
# Welcome to your Expo app 👋

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
    npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.

================
File: vintainApp/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-04T23:25:50.186Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
app/
  (tabs)/
    _layout.tsx
    index.tsx
    profile.tsx
  _layout.tsx
  +not-found.tsx
  auth.tsx
  editProfile.tsx
  listingDetail.tsx
components/
  __tests__/
    __snapshots__/
      ThemedText-test.tsx.snap
    ThemedText-test.tsx
  ui/
    IconSymbol.ios.tsx
    IconSymbol.tsx
    TabBarBackground.ios.tsx
    TabBarBackground.tsx
  Collapsible.tsx
  ExternalLink.tsx
  HapticTab.tsx
  HelloWave.tsx
  ParallaxScrollView.tsx
  ThemedText.tsx
  ThemedView.tsx
constants/
  Colors.ts
context/
  authContext.tsx
hooks/
  useColorScheme.ts
  useColorScheme.web.ts
  useThemeColor.ts
scripts/
  reset-project.js
src/
  apiService.ts
.gitignore
app.json
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: app/(tabs)/_layout.tsx
================
import { Tabs } from "expo-router";
import React from "react";
import { Platform, StyleSheet } from "react-native";

import { HapticTab } from "@/components/HapticTab";
import { IconSymbol } from "@/components/ui/IconSymbol";
import TabBarBackground from "@/components/ui/TabBarBackground";
import { Colors } from "@/constants/Colors";
import { useColorScheme } from "@/hooks/useColorScheme";

export default function TabLayout() {
  const colorScheme = useColorScheme();
  const currentColors = Colors[colorScheme ?? "light"];

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: currentColors.tabIconSelected,
        headerShown: false,
        tabBarButton: HapticTab,
        tabBarBackground: TabBarBackground,
        tabBarStyle: [
          styles.tabBar,
          Platform.select({
            ios: {
              position: "absolute",
              backgroundColor: currentColors.background,
              borderTopColor: currentColors.border,
              borderTopWidth: 1,
            },
            default: {},
          }),
        ],
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: "Home",
          tabBarIcon: ({ color }) => (
            <IconSymbol size={28} name="house.fill" color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="profile"
        options={{
          title: "Profile",
          tabBarIcon: ({ color }) => (
            <IconSymbol size={28} name="person.circle.fill" color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

const styles = StyleSheet.create({
  tabBar: {
    height: 60,
    paddingBottom: 5,
    paddingTop: 5,
  },
});

================
File: app/(tabs)/index.tsx
================
import React, { useEffect, useState } from 'react';
import {
  View, Text, Button, TextInput, FlatList, StyleSheet, TouchableOpacity,
} from 'react-native';
import { useRouter } from 'expo-router';
import { fetchAllListings, searchListings } from '../../src/apiService';

interface Listing {
  id: string;
  brand: string;
  name: string;
  description: string;
  imageUrls: string[];
}

export default function ListingListScreen() {
  const router = useRouter();

  const [listings, setListings] = useState<Listing[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const [page, setPage] = useState(1);
  const [searchTerm, setSearchTerm] = useState('');
  const [isSearching, setIsSearching] = useState(false);

  const pageSize = 5;

  useEffect(() => {
    loadListings(page);
  }, [page]);

  async function loadListings(newPage: number) {
    try {
      let data;
      if (isSearching && searchTerm.trim().length > 0) {
        data = await searchListings(searchTerm, newPage, pageSize);
      } else {
        data = await fetchAllListings(newPage, pageSize);
      }
      setListings(data.listings);
      setTotalCount(data.totalCount);
    } catch (err) {
      console.error('Failed to load listings:', err);
    }
  }

  async function onSearch() {
    setIsSearching(true);
    setPage(1);
    try {
      const data = await searchListings(searchTerm, 1, pageSize);
      setListings(data.listings);
      setTotalCount(data.totalCount);
    } catch (err) {
      console.error('Search error:', err);
    }
  }

  function onClearSearch() {
    setSearchTerm('');
    setIsSearching(false);
    setPage(1);
  }

  function onNextPage() {
    if ((page * pageSize) < totalCount) {
      setPage(prev => prev + 1);
    }
  }

  function onPrevPage() {
    if (page > 1) {
      setPage(prev => prev - 1);
    }
  }

  function renderItem({ item }: { item: Listing }) {
    return (
      <TouchableOpacity
        style={styles.listItem}
        onPress={() => router.push({
          pathname: '/listingDetail',
          params: { listingId: item.id },
        })}
      >
        <Text style={styles.listItemTitle}>
          {item.brand} - {item.name}
        </Text>
        <Text numberOfLines={2} style={styles.listItemDescription}>{item.description}</Text>
      </TouchableOpacity>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Vintage Listings</Text>

      <View style={styles.searchRow}>
        <TextInput
          style={styles.searchInput}
          placeholder="Search brand/description..."
          placeholderTextColor="#8d6e63"
          value={searchTerm}
          onChangeText={setSearchTerm}
        />
        <Button title="Search" onPress={onSearch} color="#8d6e63" />
        <Button title="Clear" onPress={onClearSearch} color="#a1887f" />
      </View>

      <FlatList
        data={listings}
        keyExtractor={(item) => item.id}
        renderItem={renderItem}
      />

      <View style={styles.paginationRow}>
        <Button title="Prev" onPress={onPrevPage} disabled={page === 1} color="#8d6e63" />
        <Text style={styles.pageText}>Page {page}</Text>
        <Button title="Next" onPress={onNextPage} disabled={(page * pageSize) >= totalCount} color="#8d6e63" />
      </View>

      <Text style={styles.totalText}>Total Listings: {totalCount}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16, backgroundColor: '#fff8e1' },
  title: { fontSize: 26, textAlign: 'center', marginBottom: 16, fontFamily: 'SpaceMono', color: '#3e2723' },
  searchRow: {
    flexDirection: 'row',
    marginBottom: 12,
    alignItems: 'center',
  },
  searchInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#8d6e63',
    borderRadius: 8,
    padding: 8,
    marginRight: 4,
    color: '#3e2723',
    fontFamily: 'SpaceMono',
    backgroundColor: '#fff',
  },
  listItem: {
    backgroundColor: '#f7f1e3',
    marginVertical: 6,
    padding: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#d7ccc8',
  },
  listItemTitle: {
    fontWeight: 'bold',
    marginBottom: 4,
    fontSize: 18,
    color: '#3e2723',
    fontFamily: 'SpaceMono',
  },
  listItemDescription: {
    fontSize: 14,
    color: '#5d4037',
    fontFamily: 'SpaceMono',
  },
  paginationRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
    alignItems: 'center',
  },
  pageText: {
    fontFamily: 'SpaceMono',
    fontSize: 16,
    color: '#3e2723',
  },
  totalText: {
    textAlign: 'center',
    marginTop: 8,
    fontFamily: 'SpaceMono',
    color: '#3e2723',
  },
});

================
File: app/(tabs)/profile.tsx
================
import React, { useContext, useEffect, useState } from 'react';
import { View, Text, StyleSheet, ActivityIndicator, Button } from 'react-native';
import { AuthContext } from '../../context/authContext';
import { fetchMyProfile } from '../../src/apiService';
import { useRouter } from 'expo-router';

export default function ProfileScreen() {
  const router = useRouter();
  const { user, signOut } = useContext(AuthContext);
  const [profile, setProfile] = useState<{
    id: string;
    name: { first: string; last: string };
    profile: { username: string; bio?: string | null };
  } | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (user?.id) {
      loadProfile(user.id);
    } else {
      setLoading(false);
    }
  }, [user]);

  async function loadProfile(id: string) {
    try {
      const data = await fetchMyProfile(id);
      setProfile(data);
    } catch (err) {
      console.error('Failed to fetch profile:', err);
    } finally {
      setLoading(false);
    }
  }

  function handleSignOut() {
    signOut().catch((err) => {
      console.error('Failed to sign out', err);
    });
  }

  if (loading) {
    return (
      <View style={styles.container}>
        <ActivityIndicator color="#8d6e63" />
      </View>
    );
  }

  if (!profile) {
    return (
      <View style={styles.container}>
        <Text style={styles.message}>No profile found.</Text>
        <Button title="Sign Out" onPress={handleSignOut} color="#8d6e63" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>
        {profile.name.first} {profile.name.last}
      </Text>
      <Text style={styles.subtitle}>@{profile.profile.username}</Text>
      <Button title="Edit Profile" onPress={() => router.push('/editProfile')} color="#8d6e63" />
      <Text style={styles.bio}>{profile.profile.bio || 'No bio available.'}</Text>
      
      <Button title="Sign Out" onPress={handleSignOut} color="#8d6e63" />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16, backgroundColor: '#fff8e1', justifyContent: 'center', alignItems: 'center' },
  title: { fontSize: 28, fontWeight: 'bold', marginBottom: 8, color: '#3e2723', fontFamily: 'SpaceMono' },
  subtitle: { fontSize: 20, color: '#5d4037', marginBottom: 12, fontFamily: 'SpaceMono' },
  bio: { fontSize: 16, marginBottom: 16, color: '#3e2723', fontFamily: 'SpaceMono', textAlign: 'center' },
  message: { fontSize: 16, marginBottom: 16, color: '#3e2723', fontFamily: 'SpaceMono' },
});

================
File: app/_layout.tsx
================
import { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';
import { useFonts } from 'expo-font';
import { Stack } from 'expo-router';
import * as SplashScreen from 'expo-splash-screen';
import { StatusBar } from 'expo-status-bar';
import { useEffect, useContext } from 'react';
import 'react-native-reanimated';
import { useColorScheme } from '@/hooks/useColorScheme';
import { AuthProvider, AuthContext } from '../context/authContext';
import AuthScreen from './auth';

SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const colorScheme = useColorScheme();
  const [loaded] = useFonts({
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  useEffect(() => {
    if (loaded) {
      SplashScreen.hideAsync();
    }
  }, [loaded]);

  if (!loaded) {
    return null;
  }

  return (
    <AuthProvider>
      <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>
        <AuthOrStack />
        <StatusBar style="auto" />
      </ThemeProvider>
    </AuthProvider>
  );
}

function AuthOrStack() {
  const { token, loading } = useContext(AuthContext);

  if (loading) {
    return null;
  }

  if (!token) {
    return <AuthScreen />;
  }

  return (
    <Stack>
      <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
      <Stack.Screen name="+not-found" />
      <Stack.Screen
        name="listingDetail"
        options={{
          headerTitle: '',
          headerBackTitle: '',
          headerTransparent: true,
          headerBackButtonMenuEnabled: false,
        }}
      />
    </Stack>
  );
}

================
File: app/+not-found.tsx
================
import { Link, Stack } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import React from 'react';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <ThemedView style={styles.container}>
        <ThemedText type="title">This screen doesn't exist.</ThemedText>
        <Link href="/" style={styles.link}>
          <ThemedText type="link">Go to home screen!</ThemedText>
        </Link>
      </ThemedView>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
    backgroundColor: '#fff8e1',
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});

================
File: app/auth.tsx
================
import React, { useContext, useState } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  StyleSheet,
  Alert,
  TouchableOpacity,
} from "react-native";
import { AuthContext } from "../context/authContext";
import { signIn as apiSignIn, signUp as apiSignUp } from "../src/apiService";

export default function AuthScreen() {
  const { signIn } = useContext(AuthContext);

  const [isSignUp, setIsSignUp] = useState(false);

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [username, setUsername] = useState("");

  const defaultRoles = ["User"];

  async function handleSubmit() {
    if (isSignUp) {
      try {
        const newAccount = await apiSignUp(
          email,
          password,
          firstName,
          lastName,
          defaultRoles,
          username
        );
        Alert.alert("Success", `Account created for ${newAccount.email}`);
        setIsSignUp(false);
      } catch (err: any) {
        Alert.alert("Error", err.message || "Failed to create account");
      }
    } else {
      try {
        const data = await apiSignIn(email, password);
        Alert.alert("Welcome", `Hello, ${data.name.first}!`);
        await signIn(data.accessToken, data);
      } catch (err: any) {
        Alert.alert("Error", err.message || "Failed to sign in");
      }
    }
  }

  function toggleMode() {
    setIsSignUp(!isSignUp);
  }

  return (
    <View style={styles.container}>
      <Text style={styles.header}>
        {isSignUp ? "Create Account" : "Sign In"}
      </Text>

      <TextInput
        style={styles.input}
        placeholder="Email"
        placeholderTextColor="#8d6e63"
        autoCapitalize="none"
        value={email}
        onChangeText={setEmail}
      />

      <TextInput
        style={styles.input}
        placeholder="Password"
        placeholderTextColor="#8d6e63"
        secureTextEntry
        value={password}
        autoCapitalize="none"
        onChangeText={setPassword}
      />

      {isSignUp && (
        <>
          <TextInput
            style={styles.input}
            placeholder="First Name"
            placeholderTextColor="#8d6e63"
            value={firstName}
            autoCapitalize="none"
            onChangeText={setFirstName}
          />
          <TextInput
            style={styles.input}
            placeholder="Last Name"
            placeholderTextColor="#8d6e63"
            value={lastName}
            autoCapitalize="none"
            onChangeText={setLastName}
          />
          <TextInput
            style={styles.input}
            placeholder="Username"
            placeholderTextColor="#8d6e63"
            value={username}
            autoCapitalize="none"
            onChangeText={setUsername}
          />
        </>
      )}

      <Button title={isSignUp ? "Sign Up" : "Sign In"} onPress={handleSubmit} color="#8d6e63" />

      <TouchableOpacity onPress={toggleMode} style={styles.toggleBtn}>
        <Text style={styles.toggleText}>
          {isSignUp
            ? "Already have an account? Sign in"
            : "Don't have an account? Sign up"}
        </Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: '#fff8e1',
    justifyContent: "center",
  },
  header: {
    fontSize: 28,
    marginBottom: 16,
    textAlign: "center",
    fontFamily: 'SpaceMono',
    color: '#3e2723',
  },
  input: {
    borderWidth: 1,
    borderColor: "#8d6e63",
    marginBottom: 12,
    padding: 10,
    borderRadius: 8,
    color: '#3e2723',
    fontFamily: 'SpaceMono',
    backgroundColor: '#fff',
  },
  toggleBtn: {
    marginTop: 12,
    alignItems: "center",
  },
  toggleText: {
    color: "#8d6e63",
    fontSize: 14,
    textDecorationLine: "underline",
    fontFamily: 'SpaceMono',
  },
});

================
File: app/editProfile.tsx
================
// vintainApp/app/editProfile.tsx
import React, { useState, useContext } from 'react';
import { View, Text, TextInput, Button, Alert, StyleSheet } from 'react-native';
import { useRouter, useLocalSearchParams } from 'expo-router';
import { updateProfile } from '../src/apiService';
import { AuthContext } from '../context/authContext';

export default function EditProfileScreen() {
  // Option 1: Get the current user ID from context
  const { user } = useContext(AuthContext);
  // Option 2: You might also pass the ID as a route parameter:
  // const { id } = useLocalSearchParams<{ id: string }>();

  // We'll use the user ID from context here.
  const userId = user?.id;
  const router = useRouter();

  // Local state for the form fields:
  const [username, setUsername] = useState(user?.profile?.username || '');
  const [bio, setBio] = useState(user?.profile?.bio || '');

  async function handleSubmit() {
    if (!userId) {
      Alert.alert("Error", "User ID not found.");
      return;
    }
    try {
      const success = await updateProfile(userId, username, bio);
      if (success) {
        Alert.alert("Success", "Profile updated successfully!");
        // Optionally, navigate back or refresh your profile:
        router.back();
      } else {
        Alert.alert("Error", "Profile update failed.");
      }
    } catch (error: any) {
      Alert.alert("Error", error.message || "Failed to update profile");
    }
  }

  return (
    <View style={styles.container}>
      <Text style={styles.header}>Edit Profile</Text>
      <TextInput
        style={styles.input}
        placeholder="Username"
        value={username}
        onChangeText={setUsername}
      />
      <TextInput
        style={[styles.input, styles.multiline]}
        placeholder="Bio"
        value={bio}
        onChangeText={setBio}
        multiline
      />
      <Button title="Save Changes" onPress={handleSubmit} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16, justifyContent: 'center' },
  header: { fontSize: 24, marginBottom: 16, textAlign: 'center' },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    marginBottom: 12,
    padding: 8,
    borderRadius: 4,
  },
  multiline: {
    height: 80,
    textAlignVertical: 'top',
  },
});

================
File: app/listingDetail.tsx
================
import React, { useEffect, useState } from 'react';
import { useLocalSearchParams } from "expo-router";
import {
  View,
  Text,
  Image,
  StyleSheet,
  ScrollView,
  SafeAreaView,
} from 'react-native';
import { fetchListingById } from '../src/apiService';

export default function ListingDetail() {
  const { listingId } = useLocalSearchParams();
  const [listing, setListing] = useState<any>(null);

  useEffect(() => {
    if (listingId) {
      loadListing(listingId as string);
    }
  }, [listingId]);

  async function loadListing(id: string) {
    try {
      const data = await fetchListingById(id);
      setListing(data);
    } catch (err) {
      console.error('Failed to fetch listing detail:', err);
    }
  }

  if (!listing) {
    return (
      <SafeAreaView style={styles.container}>
        <Text style={styles.loadingText}>Loading listing details...</Text>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <Text style={styles.title}>{listing.brand} - {listing.name}</Text>
        <Text style={styles.subtitle}>Listing ID: {listing.id}</Text>
        <Text style={styles.description}>{listing.description}</Text>
        {listing.imageUrls?.map((url: string, idx: number) => (
          <Image key={idx} source={{ uri: url }} style={styles.image} />
        ))}
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff8e1',
  },
  scrollContent: {
    padding: 16,
  },
  title: { 
    fontSize: 24, 
    fontWeight: 'bold', 
    marginBottom: 8,
    color: '#3e2723',
    fontFamily: 'SpaceMono',
  },
  subtitle: { 
    fontSize: 14, 
    marginBottom: 8, 
    color: '#5d4037',
    fontFamily: 'SpaceMono',
  },
  description: { 
    fontSize: 16, 
    marginBottom: 12,
    color: '#3e2723',
    fontFamily: 'SpaceMono',
  },
  image: { 
    width: '100%', 
    height: 200, 
    resizeMode: 'cover', 
    marginBottom: 12,
    borderRadius: 8,
  },
  loadingText: {
    fontSize: 16,
    textAlign: 'center',
    marginTop: 20,
    color: '#3e2723',
    fontFamily: 'SpaceMono',
  },
});

================
File: components/__tests__/__snapshots__/ThemedText-test.tsx.snap
================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<Text
  style={
    [
      {
        "color": "#11181C",
      },
      {
        "fontSize": 16,
        "lineHeight": 24,
      },
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
    ]
  }
>
  Snapshot test!
</Text>
`;

================
File: components/__tests__/ThemedText-test.tsx
================
import * as React from 'react';
import renderer from 'react-test-renderer';

import { ThemedText } from '../ThemedText';

it(`renders correctly`, () => {
  const tree = renderer.create(<ThemedText>Snapshot test!</ThemedText>).toJSON();

  expect(tree).toMatchSnapshot();
});

================
File: components/ui/IconSymbol.ios.tsx
================
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        { width: size, height: size },
        style,
      ]}
    />
  );
}

================
File: components/ui/IconSymbol.tsx
================
// vintainApp/components/ui/IconSymbol.tsx
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight } from 'expo-symbols';
import React from 'react';
import { OpaqueColorValue, StyleProp, TextStyle } from 'react-native'; // Import TextStyle instead of ViewStyle

// Define a mapping for icon names to MaterialIcons names.
const MAPPING = {
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as Partial<
  Record<
    import('expo-symbols').SymbolViewProps['name'],
    React.ComponentProps<typeof MaterialIcons>['name']
  >
>;

export type IconSymbolName = keyof typeof MAPPING;

export function IconSymbol({
  name,
  size = 24,
  color,
  style,  // Expect style to be a TextStyle style
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<TextStyle>;  // <-- use TextStyle here
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}

================
File: components/ui/TabBarBackground.ios.tsx
================
import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';
import { BlurView } from 'expo-blur';
import { StyleSheet } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function BlurTabBarBackground() {
  return (
    <BlurView
      tint="default"
      intensity={80}
      style={StyleSheet.absoluteFill}
    />
  );
}

export function useBottomTabOverflow() {
  const tabHeight = useBottomTabBarHeight();
  const { bottom } = useSafeAreaInsets();
  return tabHeight - bottom;
}

================
File: components/ui/TabBarBackground.tsx
================
// Shim for platforms without a blur view (web/Android)
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}

================
File: components/Collapsible.tsx
================
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity, View } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function Collapsible({ children, title }: PropsWithChildren<{ title: string }>) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView style={styles.container}>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />
        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <View style={styles.content}>{children}</View>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    marginVertical: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: '#d7ccc8',
    borderRadius: 8,
    backgroundColor: 'rgba(255,255,255,0.8)',
  },
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  content: {
    marginTop: 8,
    marginLeft: 24,
  },
});

================
File: components/ExternalLink.tsx
================
// components/ExternalLink.tsx
import { Link } from 'expo-router';
import { openBrowserAsync } from 'expo-web-browser';
import { type ComponentProps } from 'react';
import { Platform } from 'react-native';

// Define our own props: we want href to be any string.
type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href as any}  // <-- cast here so TypeScript won’t complain
      onPress={async (event) => {
        if (Platform.OS !== 'web') {
          event.preventDefault();
          await openBrowserAsync(href);
        }
      }}
    />
  );
}

================
File: components/HapticTab.tsx
================
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}

================
File: components/HelloWave.tsx
================
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withRepeat,
  withSequence,
} from 'react-native-reanimated';

import { ThemedText } from '@/components/ThemedText';

export function HelloWave() {
  const rotationAnimation = useSharedValue(0);

  useEffect(() => {
    rotationAnimation.value = withRepeat(
      withSequence(withTiming(25, { duration: 150 }), withTiming(0, { duration: 150 })),
      4
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotationAnimation.value}deg` }],
  }));

  return (
    <Animated.View style={animatedStyle}>
      <ThemedText style={styles.text}>👋</ThemedText>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  text: {
    fontSize: 28,
    lineHeight: 32,
    marginTop: -6,
    textShadowColor: 'rgba(0,0,0,0.3)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
});

================
File: components/ParallaxScrollView.tsx
================
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollViewOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/ThemedView';
import { useBottomTabOverflow } from '@/components/ui/TabBarBackground';
import { useColorScheme } from '@/hooks/useColorScheme';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollViewOffset(scrollRef);
  const bottom = useBottomTabOverflow();
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <ThemedView style={styles.container}>
      <Animated.ScrollView
        ref={scrollRef}
        scrollEventThrottle={16}
        scrollIndicatorInsets={{ bottom }}
        contentContainerStyle={{ paddingBottom: bottom }}>
        <Animated.View
          style={[
            styles.header,
            { backgroundColor: headerBackgroundColor[colorScheme] },
            headerAnimatedStyle,
          ]}>
          {headerImage}
        </Animated.View>
        <ThemedView style={styles.content}>{children}</ThemedView>
      </Animated.ScrollView>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
    borderBottomLeftRadius: 20,
    borderBottomRightRadius: 20,
  },
  content: {
    flex: 1,
    padding: 24,
    gap: 16,
  },
});

================
File: components/ThemedText.tsx
================
import { Text, type TextProps, StyleSheet } from 'react-native';
import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color, fontFamily: 'SpaceMono' },
        type === 'default' && styles.default,
        type === 'title' && styles.title,
        type === 'defaultSemiBold' && styles.defaultSemiBold,
        type === 'subtitle' && styles.subtitle,
        type === 'link' && styles.link,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 36,
    textShadowColor: 'rgba(0, 0, 0, 0.2)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: '600',
    marginBottom: 4,
  },
  link: {
    fontSize: 16,
    color: '#8d6e63',
    textDecorationLine: 'underline',
  },
});

================
File: components/ThemedView.tsx
================
import { View, type ViewProps, StyleSheet } from 'react-native';
import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[styles.container, { backgroundColor }, style]} {...otherProps} />;
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

================
File: constants/Colors.ts
================
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

/**
 * Vintage earth tone color palette.
 */
export const Colors = {
  light: {
    text: "#3e2723",           // rich dark brown
    background: "#fff8e1",     // light creamy tone
    tint: "#8d6e63",           // soft taupe
    icon: "#6d4c41",           // deep brown
    tabIconDefault: "#6d4c41",
    tabIconSelected: "#8d6e63",
    border: "#d7ccc8",
  },
  dark: {
    text: "#d7ccc8",           // pale, light brownish grey
    background: "#4e342e",     // dark chocolate brown
    tint: "#bcaaa4",           // warm grey
    icon: "#a1887f",
    tabIconDefault: "#a1887f",
    tabIconSelected: "#bcaaa4",
    border: "#8d6e63",
  },
};

================
File: context/authContext.tsx
================
// vintainApp/context/authContext.tsx
import React, { createContext, useState, useEffect, ReactNode } from 'react';
import * as SecureStore from 'expo-secure-store';
// Import setAuthToken from your API service
import { setAuthToken } from '../src/apiService';

type AuthContextType = {
  token: string | null;
  user: any | null;
  loading: boolean;
  signIn: (token: string, user: any) => Promise<void>;
  signOut: () => Promise<void>;
};

export const AuthContext = createContext<AuthContextType>({
  token: null,
  user: null,
  loading: true,
  signIn: async () => undefined,
  signOut: async () => undefined,
});

type AuthProviderProps = {
  children: ReactNode;
};

export function AuthProvider({ children }: AuthProviderProps) {
  const [token, setTokenState] = useState<string | null>(null);
  const [user, setUser] = useState<any | null>(null);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    (async () => {
      try {
        const savedToken = await SecureStore.getItemAsync('token');
        if (savedToken) {
          setTokenState(savedToken);
          // Also update our API service with the token.
          setAuthToken(savedToken);
        }
      } catch (err) {
        console.error('Error loading token from SecureStore', err);
      } finally {
        setLoading(false);
      }
    })();
  }, []);

  async function signIn(newToken: string, userData: any) {
    try {
      await SecureStore.setItemAsync('token', newToken);
      setTokenState(newToken);
      setUser(userData);
      // Set token in our API service so all future requests include it.
      setAuthToken(newToken);
    } catch (err) {
      console.error('Error saving token to SecureStore', err);
    }
  }

  async function signOut() {
    try {
      await SecureStore.deleteItemAsync('token');
      setTokenState(null);
      setUser(null);
      // Clear token in our API service.
      setAuthToken(null);
    } catch (err) {
      console.error('Error deleting token from SecureStore', err);
    }
  }

  const value: AuthContextType = {
    token,
    user,
    loading,
    signIn,
    signOut,
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

================
File: hooks/useColorScheme.ts
================
export { useColorScheme } from 'react-native';

================
File: hooks/useColorScheme.web.ts
================
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}

================
File: hooks/useThemeColor.ts
================
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}

================
File: scripts/reset-project.js
================
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const newDir = "app-example";
const newAppDir = "app";
const newDirPath = path.join(root, newDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const moveDirectories = async () => {
  try {
    // Create the app-example directory
    await fs.promises.mkdir(newDirPath, { recursive: true });
    console.log(`📁 /${newDir} directory created.`);

    // Move old directories to new app-example directory
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      const newDirPath = path.join(root, newDir, dir);
      if (fs.existsSync(oldDirPath)) {
        await fs.promises.rename(oldDirPath, newDirPath);
        console.log(`➡️ /${dir} moved to /${newDir}/${dir}.`);
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");

    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      "1. Run `npx expo start` to start a development server.\n2. Edit app/index.tsx to edit the main screen.\n3. Delete the /app-example directory when you're done referencing it."
    );
  } catch (error) {
    console.error(`Error during script execution: ${error}`);
  }
};

moveDirectories();

================
File: src/apiService.ts
================
// vintainApp/src/apiService.ts
const BASE_URL = "http://localhost:4000/graphql";

// A module-level variable to store the token:
let authToken: string | null = null;

// A function to update the token (you can call this from your AuthContext when a user signs in)
export function setAuthToken(token: string | null) {
  authToken = token;
}

async function graphQLFetch(query: string, variables: any = {}) {
  // Build headers, including Authorization if authToken exists.
  const headers: HeadersInit = {
    "Content-Type": "application/json",
    ...(authToken ? { "Authorization": `Bearer ${authToken}` } : {})
  };

  const res = await fetch(BASE_URL, {
    method: "POST",
    headers,
    body: JSON.stringify({ query, variables }),
  });
  const json = await res.json();
  if (json.errors) {
    throw new Error(json.errors[0].message || "GraphQL Error");
  }
  return json.data;
}

export async function signUp(
  email: string,
  password: string,
  firstName: string,
  lastName: string,
  roles: string[],
  username: string
) {
  try {
    const query = `
      mutation($input: NewAccount!) {
        makeAccount(input: $input) {
          id
          email
        }
      }
    `;
    // Pass username in as well
    const variables = {
      input: {
        email,
        password,
        firstName,
        lastName,
        roles,
        username,  // required
      },
    };
    const data = await graphQLFetch(query, variables);
    return data.makeAccount;
  } catch (error) {
    console.log(error);
  }
}

export async function signIn(email: string, password: string) {
  const query = `
    query($creds: Credentials!) {
      login(input: $creds) {
        id
        name { first last }
        accessToken
      }
    }
  `;
  const variables = { creds: { email, password } };
  const data = await graphQLFetch(query, variables);
  return data.login;
}

export async function fetchAllListings(page = 1, pageSize = 10) {
  const query = `
    query($page: Int!, $pageSize: Int!) {
      allListings(page: $page, pageSize: $pageSize) {
        listings { id brand name description imageUrls }
        totalCount
      }
    }
  `;
  const data = await graphQLFetch(query, { page, pageSize });
  return data.allListings;
}

export async function searchListings(searchTerm: string, page = 1, pageSize = 10) {
  const query = `
    query($searchTerm: String!, $page: Int!, $pageSize: Int!) {
      searchListings(searchTerm: $searchTerm, page: $page, pageSize: $pageSize) {
        listings { id brand name description imageUrls }
        totalCount
      }
    }
  `;
  const data = await graphQLFetch(query, { searchTerm, page, pageSize });
  return data.searchListings;
}

export async function fetchListingById(id: string) {
  const query = `
    query($id: String!) {
      listing(id: $id) {
        id
        brand
        name
        description
        imageUrls
      }
    }
  `;
  const data = await graphQLFetch(query, { id });
  return data.listing;
}

export async function fetchMyProfile(id: string) {
  const query = `
    query($id: String!) {
      account(input: $id) {
        id
        name {
          first
          last
        }
        profile {
          username
          bio
        }
      }
    }
  `;
  const variables = { id };
  const data = await graphQLFetch(query, variables);
  return data.account;
}

// vintainApp/src/apiService.ts
export async function updateProfile(
    id: string,
    username?: string,
    bio?: string
  ) {
    const query = `
      mutation UpdateProfile($id: String!, $username: String, $bio: String) {
        updateProfile(id: $id, username: $username, bio: $bio)
      }
    `;
    const variables = { id, username, bio };
    const data = await graphQLFetch(query, variables);
    return data.updateProfile; // returns true/false
  }

================
File: .gitignore
================
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example

================
File: app.json
================
{
  "expo": {
    "name": "vintainApp",
    "slug": "vintainApp",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      }
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}

================
File: package.json
================
{
  "name": "vintainapp",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "@react-navigation/stack": "^7.1.1",
    "expo": "~52.0.23",
    "expo-blur": "~14.0.1",
    "expo-constants": "~17.0.3",
    "expo-font": "~13.0.2",
    "expo-haptics": "~14.0.0",
    "expo-linking": "~7.0.3",
    "expo-router": "~4.0.15",
    "expo-secure-store": "^14.0.1",
    "expo-splash-screen": "~0.29.18",
    "expo-status-bar": "~2.0.0",
    "expo-symbols": "~0.2.0",
    "expo-system-ui": "~4.0.6",
    "expo-web-browser": "~14.0.1",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-native": "0.76.5",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-web": "~0.19.13",
    "react-native-webview": "13.12.5"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/jest": "^29.5.12",
    "@types/react": "~18.3.12",
    "@types/react-test-renderer": "^18.3.0",
    "jest": "^29.2.1",
    "jest-expo": "~52.0.2",
    "react-test-renderer": "18.3.1",
    "typescript": "^5.3.3"
  },
  "private": true
}

================
File: README.md
================
# Welcome to your Expo app 👋

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
    npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.

================
File: tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}

================
File: vintainApp/tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

.DS_Store

.expo
.vscode
node_modules
bun.lockb
yarn-error.log
yarn.lock
package-lock.json

# Web
web-build
web-report

# Electron
dist

# Gatsby
.cache
with-gatsby/public

# Next.js
.next
with-nextjs/out

# Native
*/ios/Pods

# Websockets
*/backend/.env

# local env files
*/.env*.local


.DS_Store
report.html

# Maintenance logs
.sdk-upgrade-logs
.sdk-fix-logs


/with-router-menus/ios
/with-router-menus/android
/with-canary-react-19/ios
/with-canary-react-19/android

================
File: docker-compose.yml
================
services:
  postgres:
    image: postgres:13
    environment:
      POSTGRES_USER: authuser
      POSTGRES_PASSWORD: authpass
      POSTGRES_DB: authdb
    ports:
      - "5433:5432"
    volumes:
      # Mount your .sql files if you want Postgres to run them on first startup
      - ./Backend/src/database/sql/schema.sql:/docker-entrypoint-initdb.d/2.schema.sql

    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U authuser -d authdb"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend-service:
    # Using Node 18 alpine
    image: node:18-alpine
    working_dir: /app

    # We'll mount the entire Backend folder into /app
    volumes:
      - ./Backend:/app
      - app_node_modules:/app/node_modules

    # Install deps, build the project, then run it
    command: sh -c "npm install && npm run build && npm start"

    environment:
      DATABASE_URL: "postgresql://authuser:authpass@postgres:5432/authdb"
      CRYPT_SECRET: "hello"

    depends_on:
      - postgres

    ports:
      - "4001:4000"

volumes:
  # Named volume for node_modules so it won't be overwritten by the host mount
  app_node_modules:

================
File: package.json
================
{
  "name": "vintain",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "npm run test:auth && npm run test:account && npm run test:listing && npm run test:message",
    "test:auth": "npx jest --testPathPattern 'Backend/auth/' --runInBand",
    "test:account": "npx jest --testPathPattern 'Backend/account/' --runInBand",
    "test:listing": "npx jest --testPathPattern 'Backend/listing/' --runInBand",
    "test:message": "npx jest --testPathPattern 'Backend/message/' --runInBand"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "dotenv": "^16.4.7",
    "reflect-metadata": "^0.2.2",
    "repomix": "^0.2.24",
    "supertest": "^7.0.0"
  }
}

================
File: README.md
================
# vintain
