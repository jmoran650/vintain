This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-04T00:30:55.644Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  account/
    graphql/
      resolver.ts
      schema.ts
      service.ts
    test/
      account.test.ts
  auth/
    graphql/
      resolver.ts
      schema.ts
      service.ts
    test/
      check.test.ts
      login.test.ts
  database/
    sql/
      schema.sql
  listing/
    graphql/
      resolver.ts
      schema.ts
      service.ts
    test/
      listing.test.ts
  message/
    graphql/
      resolver.ts
      schema.ts
      service.ts
    test/
      message.test.ts
  orders/
    graphql/
      resolver.ts
      schema.ts
      service.ts
    test/
      order.test.ts
test/
  account/
    testdata/
      data.sql
      schema.sql
  auth/
    testdata/
      data.sql
      schema.sql
  listing/
    testdata/
      data.sql
      schema.sql
  message/
    testdata/
      data.sql
      schema.sql
  orders/
    testdata/
      data.sql
      schema.sql
  dbTest.ts
babel.config.js
db.ts
index.ts
jest.config.js
package.json
tsconfig.json

================================================================
Files
================================================================

================
File: src/account/graphql/resolver.ts
================
// src/account/graphql/resolver.ts

import { Authorized, Query, Resolver, Ctx, Mutation, Arg } from "type-graphql";
import { Request } from "express";
import { AccountService } from "./service";
import { Account, Email, NewAccount, UUID } from "./schema";

@Resolver()
export class AccountResolver {
  @Authorized()
  @Query(() => Account)
  async account(
    @Ctx() _req: Request,
    @Arg("input") ID: UUID
  ): Promise<Account> {
    return new AccountService().getAccount(ID);
  }

  @Authorized()
  @Query(() => Account)
  async accountByEmail(
    @Ctx() _req: Request,
    @Arg("input") email: Email
  ): Promise<Account> {
    email = email.toLowerCase();
    return new AccountService().getAccountByEmail(email);
  }

  @Authorized()
  @Query(() => [Account])
  async allAccounts(@Ctx() _req: Request): Promise<Account[]> {
    return new AccountService().getAllAccounts();
  }

  @Authorized()
  @Query(() => [Account])
  async restrictedVendors(@Ctx() _req: Request): Promise<Account[]> {
    const all = await new AccountService().getAllAccounts();
    return all.filter((acc) => acc.restricted === true && acc.roles.includes("Vendor"));
  }

  // Public operation: account creation remains unprotected.
  @Mutation(() => Account)
  async makeAccount(
    @Arg("input") newAccount: NewAccount,
    @Ctx() _request: Request
  ): Promise<Account> {
    newAccount.email = newAccount.email.toLowerCase();
    return new AccountService().makeAccount(newAccount);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteAccount(
    @Arg("input") accountID: UUID,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return new AccountService().deleteAccount(accountID);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteAccountByEmail(
    @Arg("input") accountEmail: Email,
    @Ctx() _request: Request
  ): Promise<boolean> {
    accountEmail = accountEmail.toLowerCase();
    return new AccountService().deleteAccountByEmail(accountEmail);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async suspendAccount(
    @Arg("input") accountID: UUID,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return new AccountService().suspendAccount(accountID);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async suspendAccountByEmail(
    @Arg("input") accountEmail: Email,
    @Ctx() _request: Request
  ): Promise<boolean> {
    accountEmail = accountEmail.toLowerCase();
    return new AccountService().suspendAccountByEmail(accountEmail);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async resumeAccount(
    @Arg("input") accountID: UUID,
    @Ctx() _request: Request
  ): Promise<boolean> {
    return new AccountService().resumeAccount(accountID);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async resumeAccountByEmail(
    @Arg("input") accountEmail: Email,
    @Ctx() _request: Request
  ): Promise<boolean> {
    accountEmail = accountEmail.toLowerCase();
    return new AccountService().resumeAccountByEmail(accountEmail);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async updateProfile(
    @Arg("id") id: UUID,
    @Arg("username", { nullable: true }) username?: string,
    @Arg("bio", { nullable: true }) bio?: string
  ): Promise<boolean> {
    return new AccountService().updateProfile(id, username, bio);
  }
}

================
File: src/account/graphql/schema.ts
================
// Backend/src/auth/graphql/schema.ts

import { ObjectType, InputType, Field } from "type-graphql";
import { MinLength } from "class-validator";

export type UUID = string;
export type Email = string;

@ObjectType()
export class Name {
  @Field()
  @MinLength(1)
  first!: string;

  @Field()
  @MinLength(1)
  last!: string;
}

/**
 * A profile object with required `username` and optional `bio`.
 */
@ObjectType()
export class Profile {
  // Make username non-null in GraphQL
  @Field()
  @MinLength(1)
  username!: string;

  @Field({ nullable: true })
  bio?: string;
}

/**
 * The Account object includes `profile` as a non-null field,
 * so we always return an object (even if it has default values).
 */
@ObjectType()
export class Account {
  @Field()
  id!: UUID;

  @Field()
  email!: Email;

  @Field()
  name!: Name;

  @Field(() => [String!])
  roles!: string[];

  @Field()
  restricted!: boolean;

  // Profile is always defined, but inside it `username` is required, `bio` is optional.
  @Field(() => Profile)
  profile!: Profile;
}

/**
 * Input for creating a new account.
 * We now require `username`, while `bio` remains optional.
 */
@InputType()
@ObjectType()
export class NewAccount {
  @Field()
  email!: Email;

  @Field()
  @MinLength(1)
  password!: string;

  @Field()
  @MinLength(1)
  firstName!: string;

  @Field()
  @MinLength(1)
  lastName!: string;

  @Field(() => [String!])
  roles!: string[];

  @Field()
  @MinLength(1)
  username!: string;

  @Field({ nullable: true })
  bio?: string;
}

================
File: src/account/graphql/service.ts
================
// Backend/src/auth/graphql/service.ts

import { pool } from "../../../db";
import { NewAccount, Account } from "./schema";
import { UUID, Email } from "./schema";

export class AccountService {
  public async getAccount(id: UUID): Promise<Account> {
    const select = `
      SELECT
        id,
        email,
        restricted,
        data->'name' AS name,
        data->'roles' AS roles,
        data->'profile' AS profile
      FROM account
      WHERE id = $1
    `;
    const query = { text: select, values: [id] };
    const { rows } = await pool.query(query);

    if (rows.length === 0) {
      throw new Error("Account with given ID does not exist.");
    }

    const row = rows[0];
    // row.profile might be null or {username, bio} or partial
    return {
      id: row.id,
      email: row.email,
      restricted: row.restricted,
      name: row.name,         // { first, last }
      roles: row.roles || [],
      // Always return a Profile object:
      profile: {
        username: row.profile?.username ?? "", // fallback to empty string
        bio: row.profile?.bio ?? null,
      },
    };
  }

  public async getAccountByEmail(email: Email): Promise<Account> {
    const select = `
      SELECT
        id,
        email,
        restricted,
        data->'name' as name,
        data->'roles' as roles,
        data->'profile' as profile
      FROM account
      WHERE email = $1
    `;
    const query = { text: select, values: [email] };
    const { rows } = await pool.query(query);

    if (rows.length == 0) {
      throw new Error("Account with given Email does not exist.");
    }

    const row = rows[0];
    return {
      id: row.id,
      email: row.email,
      restricted: row.restricted,
      name: row.name,
      roles: row.roles || [],
      profile: {
        username: row.profile?.username ?? "",
        bio: row.profile?.bio ?? null,
      },
    };
  }

  public async getAllAccounts(): Promise<Account[]> {
    const select = `
      SELECT
        id,
        email,
        restricted,
        data->'name' as name,
        data->'roles' as roles,
        data->'profile' as profile
      FROM account
    `;
    const { rows } = await pool.query(select);

    return rows.map((row: any) => ({
      id: row.id,
      email: row.email,
      restricted: row.restricted,
      name: row.name,
      roles: row.roles || [],
      profile: {
        username: row.profile?.username ?? "",
        bio: row.profile?.bio ?? null,
      },
    }));
  }

  public async makeAccount(info: NewAccount): Promise<Account> {
    const restrictedVal = info.roles.includes("Vendor") || info.roles.includes("vendor");

    // Insert includes 'profile' with 'username' and optional 'bio'
    const insert = `
      INSERT INTO account (email, restricted, data)
      VALUES (
        $1::text,
        $7,
        jsonb_build_object(
          'name', jsonb_build_object(
            'first', $2::text,
            'last', $3::text
          ),
          'password', crypt($4::text, '${process.env.CRYPT_SECRET}'),
          'roles', $5::text[],
          'profile', jsonb_build_object(
            'username', $6::text,
            'bio', $8::text
          )
        )
      )
      RETURNING id
    `;
    const query = {
      text: insert,
      values: [
        info.email,        // $1
        info.firstName,    // $2
        info.lastName,     // $3
        info.password,     // $4
        info.roles,        // $5
        info.username,     // $6
        restrictedVal,     // $7
        info.bio || null,  // $8
      ],
    };
    const { rows } = await pool.query(query);

    // Return the newly created account data
    return {
      id: rows[0].id,
      email: info.email,
      name: { first: info.firstName, last: info.lastName },
      roles: info.roles,
      restricted: restrictedVal,
      profile: {
        username: info.username,
        bio: info.bio || undefined,
      },
    };
  }

  public async deleteAccount(id: UUID): Promise<boolean> {
    const del = `DELETE FROM account WHERE (id=$1)`;
    await pool.query({ text: del, values: [id] });
    return true;
  }

  public async deleteAccountByEmail(email: string): Promise<boolean> {
    const del = `DELETE FROM account WHERE (email=$1)`;
    await pool.query({ text: del, values: [email] });
    return true;
  }

  private async modifyRestricted(byWhat: "id" | "email", setTo: boolean, byValue: UUID | Email) {
    const update = `UPDATE account SET restricted = $2 WHERE (${byWhat}=$1)`;
    await pool.query({ text: update, values: [byValue, setTo] });
    return true;
  }

  public async suspendAccount(id: UUID): Promise<boolean> {
    return this.modifyRestricted("id", true, id);
  }

  public async resumeAccount(id: UUID): Promise<boolean> {
    return this.modifyRestricted("id", false, id);
  }

  public async suspendAccountByEmail(email: Email): Promise<boolean> {
    return this.modifyRestricted("email", true, email);
  }

  public async resumeAccountByEmail(email: Email): Promise<boolean> {
    return this.modifyRestricted("email", false, email);
  }

  public async updateProfile(
    id: UUID,
    username?: string,
    bio?: string
  ): Promise<boolean> {
    // 1) fetch existing profile subobject from DB
    const select = `
      SELECT data->'profile' as profile
      FROM account
      WHERE id = $1
    `;
    const { rows } = await pool.query({ text: select, values: [id] });

    if (rows.length === 0) {
      throw new Error("No account found for that ID.");
    }

    // oldProfile is either null or { username, bio }
    const oldProfile = rows[0].profile || {};

    // 2) Merge old data with new
    const newProfile = {
      ...oldProfile,
      ...(username !== undefined ? { username } : {}),
      ...(bio !== undefined ? { bio } : {}),
    };

    // 3) Update the row in DB
    const updateSql = `
      UPDATE account
      SET data = jsonb_set(
        data,
        '{profile}',
        $2::jsonb,  -- the new profile object
        true
      )
      WHERE id = $1
    `;
    await pool.query({
      text: updateSql,
      values: [id, JSON.stringify(newProfile)],
    });

    return true;
  }

}

================
File: src/account/test/account.test.ts
================
//Backend/src/auth/graphql/service.ts
import * as http from "http";
import supertest from "supertest";

import { createApp } from "../../../index";
import { resetForDomain, shutdown } from "../../../test/dbTest";

let server: http.Server<
  typeof http.IncomingMessage,
  typeof http.ServerResponse
>;

beforeAll(async () => {
  // 1) Clear + seed domain's DB
  await resetForDomain("account");

  // 2) Start the app
  const app = await createApp();
  server = http.createServer(app);
  server.listen(0);
}, 10000);

afterAll((done) => {
  shutdown(() => {
    server.close(done);
  });
});

let id = "";

it("Can get member by ID", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        account(input: "00000000-b7a7-4100-8b2d-309908b444f5") {
          id name { first last } email
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.account.email).toBe("sammy@slugmart.com");
      expect(res.body.data.account.name.first).toBe("Sammy");
      expect(res.body.data.account.name.last).toBe("Slug");
    });
});

it("Cant get member by non-existent ID", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        account(input: "10000000-b7a7-4100-8b2d-309908b444f5") {
          id name { first last } email
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeDefined();
      expect(res.body.errors.length > 0).toBe(true);
      // no valid data expected
    });
});

it("Can get member by email", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        accountByEmail(input: "sammy@slugmart.com") {
          id name { first last } email
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.accountByEmail.email).toBe("sammy@slugmart.com");
      expect(res.body.data.accountByEmail.name.first).toBe("Sammy");
      expect(res.body.data.accountByEmail.name.last).toBe("Slug");
    });
});

it("Cant get member by non-existent email", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        accountByEmail(input: "noEmail@slugmart.com") {
          id name { first last } email
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeDefined();
      expect(res.body.errors.length > 0).toBe(true);
    });
});

it("Can make account", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation m {
        makeAccount(input: {email:"SlugAdmin@mart.com", password:"abc", firstName:"Slug", lastName:"min", roles:["Admin", "Shopper"]}) {
          id
          email
          name { first last }
          roles
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.makeAccount.email).toBe("slugadmin@mart.com");
      expect(res.body.data.makeAccount.name.first).toBe("Slug");
      expect(res.body.data.makeAccount.name.last).toBe("min");
      id = res.body.data.makeAccount.id;
    });
});

it("Cant make account with same email address", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation m {
        makeAccount(input: {email:"SlugAdmin@mart.com", password:"abc", firstName:"Slug", lastName:"min", roles:["Admin", "Shopper"]}) {
          id
          email
          name { first last }
          roles
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeDefined();
      expect(res.body.errors.length > 0).toBe(true);
    });
});

it("Can delete account", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation delete {
        deleteAccount(input: "${id}")
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.deleteAccount).toBe(true); // Assuming deleteAccount returns true on success
    });
});

it("Member should no longer exist", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        account(input: "${id}") {
          id name { first last } email
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeDefined();
      expect(res.body.errors.length > 0).toBe(true);
    });
});

it("Make another account", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation m {
        makeAccount(input: {email:"SlugAdmin@mart.com", password:"abc", firstName:"Slug", lastName:"min", roles:["Admin", "Shopper"]}) {
          id
          email
          name { first last }
          roles
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.makeAccount.email).toBe("slugadmin@mart.com");
      expect(res.body.data.makeAccount.name.first).toBe("Slug");
      expect(res.body.data.makeAccount.name.last).toBe("min");
      id = res.body.data.makeAccount.id;
    });
});

it("Can delete account by email", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation delete {
        deleteAccountByEmail(input: "SlugAdmin@mart.com")
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.deleteAccountByEmail).toBe(true); // Assuming returns true on success
    });
});

it("Member should no longer exist (by email)", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        accountByEmail(input: "slugAdmin@mart.com") {
          id name { first last } email
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeDefined();
      expect(res.body.errors.length > 0).toBe(true);
    });
});

it("Make another account (again)", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation m {
        makeAccount(input: {email:"SlugAdmin@mart.com", password:"abc", firstName:"Slug", lastName:"min", roles:["Admin", "Shopper"]}) {
          id
          email
          name { first last }
          roles
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.makeAccount.email).toBe("slugadmin@mart.com");
      expect(res.body.data.makeAccount.name.first).toBe("Slug");
      expect(res.body.data.makeAccount.name.last).toBe("min");
      id = res.body.data.makeAccount.id;
    });
});

it("Can suspend account by ID", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation suspend {
        suspendAccount(input: "${id}")
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.suspendAccount).toBe(true); // Assuming returns true on success
    });
});

it("Account should be suspended", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        account(input: "${id}") {
          id name { first last } email restricted
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.account.restricted).toBe(true);
    });
});

it("Can resume account by ID", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation resume {
        resumeAccount(input: "${id}")
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.resumeAccount).toBe(true); // Assuming returns true on success
    });
});

it("Account should not be suspended", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        account(input: "${id}") {
          id name { first last } email restricted
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.account.restricted).toBe(false);
    });
});

///// Now by email

it("Can suspend account by email", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation suspend {
        suspendAccountByEmail(input: "slugadmin@mart.com")
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.suspendAccountByEmail).toBe(true); // Assuming returns true on success
    });
});

it("Account should be suspended (by email)", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        accountByEmail(input: "slugadmin@mart.com") {
          id name { first last } email restricted
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.accountByEmail.restricted).toBe(true);
    });
});

it("Can resume account by email", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation resume {
        resumeAccountByEmail(input: "slugadmin@mart.com")
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.resumeAccountByEmail).toBe(true); // Assuming returns true on success
    });
});

it("Account should not be suspended (by email)", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        accountByEmail(input: "slugadmin@mart.com") {
          id name { first last } email restricted
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.accountByEmail.restricted).toBe(false);
    });
});

it("Make vendor account", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation m {
        makeAccount(input: {email:"vendor@test.com", password:"abc", firstName:"Slug", lastName:"min", roles:["Vendor"]}) {
          id
          email
          name { first last }
          roles
          restricted
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.makeAccount.email).toBe("vendor@test.com");
      expect(res.body.data.makeAccount.name.first).toBe("Slug");
      expect(res.body.data.makeAccount.name.last).toBe("min");
      expect(res.body.data.makeAccount.restricted).toBe(true);
      id = res.body.data.makeAccount.id;
    });
});

it("Can get all accounts", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query g {
        allAccounts {
          id email name { first last } roles restricted
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      //console.log('RES GET ALL ACCOUNTSA:', res.body);
      expect(res.body.data.allAccounts.length).toBeGreaterThan(0);
    });
});

================
File: src/auth/graphql/resolver.ts
================
// src/auth/graphql/resolver.ts

import { Resolver, Query, Ctx, Arg } from "type-graphql";
import { Authenticated, Credentials, SessionAccount } from "./schema";
import { AuthService } from "./service";

@Resolver()
export class AuthResolver {
  @Query(() => Authenticated)
  async login(
    @Ctx() req: Request,
    @Arg("input") creds: Credentials
  ): Promise<Authenticated> {
    const account = await new AuthService().login(creds);
    if (!account) {
      throw new Error("Invalid Credentials");
    }
    return account;
  }

  @Query(() => SessionAccount)
  async check(
    @Ctx() req: Request,
    @Arg("input") accessToken: string
  ): Promise<SessionAccount> {
    return new AuthService().check(accessToken);
  }
}

================
File: src/auth/graphql/schema.ts
================
//Backend/src/auth/graphql/schema.ts
import { ObjectType, InputType, Field } from "type-graphql";
import {Request} from "express";
import {MinLength} from 'class-validator';
import {Name} from '../../account/graphql/schema'
/**
 * From https://tsoa-community.github.io/docs/examples.html
 * Stringified UUIDv4.
 * See [RFC 4112](https://tools.ietf.org/html/rfc4122)
 * @pattern [0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}
 * @format uuid
 */
export type UUID = string;

/**
 * From https://tsoa-community.github.io/docs/examples.html
 * Stringified UUIDv4.
 * See [RFC 4112](https://tools.ietf.org/html/rfc4122)
 * @pattern ^[\w-.]+@([\w-]+\.)+[\w-]{2,4}$
 * @format email
 */
export type Email = string;



@InputType()
@ObjectType()
export class Authenticated {
  @Field()
  @MinLength(1)
  id!:string

  @Field()
  name!:Name

  @Field()
  @MinLength(1)
  accessToken!:string
}

ObjectType()
export class Account {
  @Field()
  id!:UUID

  @Field()
  email!:Email

  @Field()
  name!:Name

  @Field()
  @MinLength(1)
  accessToken!:string

  // TODO: IMPLEMENT TWO TOKENS AUTH
  // @Field()
  // @MinLength(1)
  // refreshToken!:string

}

@InputType()
@ObjectType()
export class Credentials {
  @Field()
  @MinLength(1)
  email!:Email

  @Field()
  @MinLength(1)
  password!:string

}

@InputType()
@ObjectType()
export class SessionAccount {

  @Field()
  @MinLength(1)
  id!: string;

}

================
File: src/auth/graphql/service.ts
================
//Backend/src/auth/graphql/service.ts
import { pool } from "../../../db";
import * as jwt from "jsonwebtoken";
import { Credentials, Authenticated, Account, SessionAccount } from "./schema";

export class AuthService {
  private async find(creds: Credentials): Promise<Account | undefined> {
    const select = `SELECT id, email, data->'name' as name, data->'roles' as roles FROM account 
    WHERE email = $1 AND
    (data->>'password') = crypt($2,'${process.env.CRYPT_SECRET}') AND restricted = FALSE`;

    const query = {
      text: select,
      values: [creds.email, creds.password],
    };

    const { rows } = await pool.query(query);

    if (rows.length != 1) {
      return undefined;
    }

    return rows[0];
  }

  public async login(creds: Credentials): Promise<Authenticated | undefined> {
    const account = await this.find(creds);
    if (!account) {
      return undefined;
    }
    const accessToken = jwt.sign(
      {
        id: account.id,
      },
      `${process.env.MASTER_SECRET}`,
      { algorithm: "HS256" }
    );

    return { id: account.id, name: account.name, accessToken: accessToken };
  }

  public async check(accessToken: string): Promise<SessionAccount> {
    return new Promise((resolve, reject) => {
      try {
        jwt.verify(
          accessToken,
          `${process.env.MASTER_SECRET}`,
          (err: jwt.VerifyErrors | null, decoded?: object | string) => {
            if (err) {
              reject(err);
            }
            const account = decoded as { id: string };
            resolve({ id: account.id });
          }
        );
      } catch (e) {
        reject(e);
      }
    });
  }
}

================
File: src/auth/test/check.test.ts
================
import { request, gql } from 'graphql-request';

const endpoint = process.env.AUTH_ENDPOINT || 'http://localhost:4001/graphql';

interface LoginForCheckResponse {
  login: {
    id: string;
    accessToken: string;
  };
}

interface CheckResponse {
  check: {
    id: string;
  };
}

describe('AuthService check', () => {
  let accessToken: string;
  beforeAll(async () => {
    const loginQuery = gql`
      query Login($input: Credentials!) {
        login(input: $input) {
          id
          accessToken
        }
      }
    `;

    const variables = { input: { email: "test@example.com", password: "password" } };
    const response = await request<LoginForCheckResponse>(endpoint, loginQuery, variables);
    accessToken = response.login.accessToken;
  });

  it('should return an account id with a valid token', async () => {
    const checkQuery = gql`
      query Check($input: String!) {
        check(input: $input) {
          id
        }
      }
    `;

    const checkVars = { input: accessToken };
    const checkResponse = await request<CheckResponse>(endpoint, checkQuery, checkVars);
    expect(checkResponse.check.id).toBeTruthy();
  });
});

================
File: src/auth/test/login.test.ts
================
import { gql, request } from "graphql-request";

let endpoint = "";

import * as http from "http";
import { AddressInfo } from "net";

import { createApp } from "../../../index";
import { resetForDomain, shutdown } from "../../../test/dbTest";

let server: http.Server<
  typeof http.IncomingMessage,
  typeof http.ServerResponse
>;

beforeAll(async () => {
  await resetForDomain("auth");

  const app = await createApp();
  server = http.createServer(app);

  // Wait until the server is actually listening on an ephemeral port
  await new Promise<void>((resolve) => {
    server.listen(0, () => {
      const address = server.address() as AddressInfo;
      // Now we can construct the endpoint
      endpoint = `http://localhost:${address.port}/graphql`;
      resolve();
    });
  });
}, 10000);

afterAll((done) => {
  shutdown(() => {
    server.close(done);
  });
});

interface LoginResponse {
  login: {
    id: string;
    name: {
      first: string;
      last: string;
    };
    accessToken: string;
  };
}

describe("AuthService login", () => {
  it("should login with valid credentials", async () => {
    const query = gql`
      query Login($input: Credentials!) {
        login(input: $input) {
          id
          name {
            first
            last
          }
          accessToken
        }
      }
    `;

    const variables = {
      input: {
        email: "test@example.com",
        password: "password",
      },
    };

    const response = await request<LoginResponse>(endpoint, query, variables);
    expect(response.login).toBeDefined();
    expect(response.login.id).toBeTruthy();
    expect(response.login.name.first).toBe("John"); // Based on seeded data
    expect(response.login.name.last).toBe("Doe");
    expect(response.login.accessToken).toBeTruthy();
  });

  it("should return an error for invalid credentials", async () => {
    const query = gql`
      query Login($input: Credentials!) {
        login(input: $input) {
          id
          name {
            first
            last
          }
          accessToken
        }
      }
    `;

    const variables = {
      input: {
        email: "wrong@example.com",
        password: "wrongpass",
      },
    };

    await expect(
      request<LoginResponse>(endpoint, query, variables)
    ).rejects.toThrow("Invalid Credentials");
  });
});

================
File: src/database/sql/schema.sql
================
--Backend/src/database/sql/schema.sql
-- 2.schema.sql
-- Enable pgcrypto for UUID generation and crypt()
CREATE EXTENSION IF NOT EXISTS pgcrypto;

DROP TABLE IF EXISTS account CASCADE;
-- Create the account table
CREATE TABLE account (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text UNIQUE NOT NULL,
  data jsonb NOT NULL,
  restricted boolean NOT NULL DEFAULT false
);

CREATE TABLE listing (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id uuid NOT NULL,
  data jsonb NOT NULL
);

CREATE TABLE message (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  item_owner_id uuid NOT NULL,
  sender_id uuid NOT NULL,
  data jsonb NOT NULL
);

DROP TABLE IF EXISTS orders CASCADE;

CREATE TABLE orders (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- The account who placed the order
  buyer_id uuid NOT NULL,
  
  -- The account (shop or seller) fulfilling the order
  seller_id uuid NOT NULL,
  
  -- For now, we’ll store an order or shipping status as a simple text column
  shipping_status text NOT NULL DEFAULT 'pending',

  item_id uuid NOT NULL,
  
  -- Possibly a JSONB for extra data (items, totals, addresses, etc.)
  data jsonb,
  
  CONSTRAINT fk_order_buyer
    FOREIGN KEY (buyer_id)
    REFERENCES account (id)
    ON DELETE CASCADE,

  CONSTRAINT fk_order_seller
    FOREIGN KEY (seller_id)
    REFERENCES account (id)
    ON DELETE CASCADE,
  
  CONSTRAINT fk_order_item
    FOREIGN KEY (item_id)
    REFERENCES listing (id)
);

================
File: src/listing/graphql/resolver.ts
================
// src/listing/graphql/resolver.ts

import { Authorized, Query, Resolver, Mutation, Arg, Int, Ctx } from "type-graphql";
import { Request } from "express";
import { ListingService } from "./service";
import { Listing, NewListing, UUID, PaginatedListings } from "./schema";

@Resolver()
export class ListingResolver {
  @Authorized()
  @Query(() => Listing)
  async listing(
    @Ctx() _req: Request,
    @Arg("id") id: UUID
  ): Promise<Listing> {
    return new ListingService().getListing(id);
  }

  @Authorized()
  @Query(() => PaginatedListings)
  async allListings(
    @Ctx() _req: Request,
    @Arg("page", () => Int, { defaultValue: 1 }) page: number,
    @Arg("pageSize", () => Int, { defaultValue: 10 }) pageSize: number
  ): Promise<PaginatedListings> {
    return new ListingService().getAllListings(page, pageSize);
  }

  @Authorized()
  @Mutation(() => Listing)
  async createListing(
    @Arg("input") listingInfo: NewListing,
    @Ctx() _req: Request
  ): Promise<Listing> {
    return new ListingService().createListing(listingInfo);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteListing(
    @Arg("id") listingId: UUID,
    @Ctx() _req: Request
  ): Promise<boolean> {
    return new ListingService().deleteListing(listingId);
  }

  @Authorized()
  @Query(() => PaginatedListings)
  async searchListings(
    @Arg("searchTerm") searchTerm: string,
    @Arg("page", () => Int, { defaultValue: 1 }) page: number,
    @Arg("pageSize", () => Int, { defaultValue: 10 }) pageSize: number
  ): Promise<PaginatedListings> {
    const { listings, totalCount } = await new ListingService().searchListings(
      searchTerm,
      page,
      pageSize
    );
    return { listings, totalCount };
  }
}

================
File: src/listing/graphql/schema.ts
================
//Backend/src/listing/graphql/schema.ts
import { Field, InputType, ObjectType, Int } from "type-graphql";
import { MinLength } from "class-validator";

/** Our custom type for UUID strings. */
export type UUID = string;

@ObjectType()
export class Listing {
  @Field()
  id!: UUID;

  @Field()
  ownerId!: UUID;

  @Field()
  @MinLength(1)
  brand!: string;

  @Field()
  @MinLength(1)
  name!: string;

  @Field()
  @MinLength(1)
  description!: string;

  @Field(() => [String])
  imageUrls!: string[];
}

@InputType()
export class NewListing {
  @Field()
  ownerId!: UUID;

  @Field()
  @MinLength(1)
  brand!: string;

  @Field()
  @MinLength(1)
  name!: string;

  @Field()
  @MinLength(1)
  description!: string;

  @Field(() => [String])
  imageUrls!: string[];
}

/**
 * For returning paginated listing results
 * (listings + totalCount).
 */
@ObjectType()
export class PaginatedListings {
  @Field(() => [Listing])
  listings!: Listing[];

  @Field(() => Int)
  totalCount!: number;
}

================
File: src/listing/graphql/service.ts
================
//Backend/src/listing/graphql/service.ts
import { pool } from "../../../db";
import { NewListing, Listing, UUID } from "./schema";

export class ListingService {
  /**
   * Fetch all listings with pagination.
   * @param page The page number (>= 1).
   * @param pageSize The number of listings per page (>= 1).
   *
   * Returns { listings, totalCount }.
   */
  public async getAllListings(
    page: number = 1,
    pageSize: number = 10
  ): Promise<{ listings: Listing[]; totalCount: number }> {
    // Prevent negative or zero inputs
    if (page < 1) page = 1;
    if (pageSize < 1) pageSize = 10;

    const offset = (page - 1) * pageSize;

    // 1) total count for pagination
    const countResult = await pool.query(
      `SELECT COUNT(*) AS total FROM listing`
    );
    const totalCount = parseInt(countResult.rows[0].total, 10);

    // 2) query the rows
    const select = `
      SELECT
        id,
        owner_id as "ownerId",
        data->>'brand' as brand,
        data->>'name' as name,
        data->>'description' as description,
        data->'imageUrls' as "imageUrls"
      FROM listing
      -- If you have a created_at column:
      -- ORDER BY created_at DESC
      LIMIT $1
      OFFSET $2
    `;

    const { rows } = await pool.query({
      text: select,
      values: [pageSize, offset],
    });

    // ensure imageUrls is not null
    const listings = rows.map((row: any) => ({
      ...row,
      imageUrls: row.imageUrls || [],
    }));

    return { listings, totalCount };
  }

  /**
   * Get a single listing by ID.
   */
  public async getListing(id: UUID): Promise<Listing> {
    const select = `
      SELECT
        id,
        owner_id as "ownerId",
        data->>'brand' as brand,
        data->>'name' as name,
        data->>'description' as description,
        data->'imageUrls' as "imageUrls"
      FROM listing
      WHERE id = $1
    `;
    const { rows } = await pool.query({ text: select, values: [id] });
    if (rows.length === 0) {
      throw new Error("Listing with given ID does not exist.");
    }
    rows[0].imageUrls = rows[0].imageUrls || [];
    return rows[0];
  }

  /**
   * Create a new listing.
   */
  public async createListing(info: NewListing): Promise<Listing> {
    const insert = `
      INSERT INTO listing (owner_id, data)
      VALUES (
        $1::uuid,
        jsonb_build_object(
          'brand', $2::text,
          'name', $3::text,
          'description', $4::text,
          'imageUrls', $5::text[]
        )
      )
      RETURNING id;
    `;
    const { rows } = await pool.query({
      text: insert,
      values: [
        info.ownerId,
        info.brand,
        info.name,
        info.description,
        info.imageUrls,
      ],
    });

    return {
      id: rows[0].id,
      ownerId: info.ownerId,
      brand: info.brand,
      name: info.name,
      description: info.description,
      imageUrls: info.imageUrls,
    };
  }

  /**
   * Delete a listing by ID.
   */
  public async deleteListing(id: UUID): Promise<boolean> {
    const del = `DELETE FROM listing WHERE id = $1`;
    await pool.query({ text: del, values: [id] });
    return true;
  }

  /**
   * Search by substring in brand/name/description (case-insensitive) with pagination.
   *
   * @param searchTerm The text we want to find in brand/name/description
   * @param page The page number (>= 1)
   * @param pageSize The number of results per page (>= 1)
   * @returns {
   *   listings: Listing[],
   *   totalCount: number
   * }
   */
  public async searchListings(
    searchTerm: string,
    page: number = 1,
    pageSize: number = 10
  ): Promise<{ listings: Listing[]; totalCount: number }> {
    // 1) Normalize page/pageSize
    if (page < 1) page = 1;
    if (pageSize < 1) pageSize = 10;

    // We'll wrap the term in % ... % for a contains match
    const ilikeValue = `%${searchTerm}%`;

    // 2) Determine totalCount for all matched rows (no LIMIT here)
    const countSql = `
     SELECT COUNT(*) AS total
     FROM listing
     WHERE
       (data->>'brand') ILIKE $1
       OR (data->>'name') ILIKE $1
       OR (data->>'description') ILIKE $1
   `;
    const countResult = await pool.query({
      text: countSql,
      values: [ilikeValue],
    });
    const totalCount = parseInt(countResult.rows[0].total, 10);

    // 3) Do the actual SELECT with LIMIT & OFFSET
    const offset = (page - 1) * pageSize;
    const selectSql = `
     SELECT
       id,
       owner_id AS "ownerId",
       data->>'brand' AS brand,
       data->>'name' AS name,
       data->>'description' AS description,
       data->'imageUrls' AS "imageUrls"
     FROM listing
     WHERE
       (data->>'brand') ILIKE $1
       OR (data->>'name') ILIKE $1
       OR (data->>'description') ILIKE $1
     LIMIT $2
     OFFSET $3
   `;

    const { rows } = await pool.query({
      text: selectSql,
      values: [ilikeValue, pageSize, offset],
    });

    // 4) Map rows to your Listing shape, ensuring imageUrls isn’t null
    const listings: Listing[] = rows.map((r: any) => ({
      ...r,
      imageUrls: r.imageUrls || [],
    }));

    // 5) Return listings and the total match count
    return { listings, totalCount };
  }
}

================
File: src/listing/test/listing.test.ts
================
import * as http from "http";
import supertest from "supertest";

import { createApp } from "../../../index"; // This should be your listing service entry point
import { resetForDomain, shutdown } from "../../../test/dbTest";

let server: http.Server<
  typeof http.IncomingMessage,
  typeof http.ServerResponse
>;

beforeAll(async () => {
  // 1) Clear + seed domain's DB
  await resetForDomain("listing");

  // 2) Start the app
  const app = await createApp();
  server = http.createServer(app);
  server.listen(0);
}, 10000);

afterAll((done) => {
  shutdown(() => {
    server.close(done);
  });
});

let createdListingId = "";

// Example test: get listing by ID that exists in test data
it("Can get listing by ID", async () => {
  // This ID should exist in your testdata/data.sql for listings
  const existingId = "00000000-b7a7-4100-8b2d-309908b444f5";
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        listing(id: "${existingId}") {
          id
          ownerId
          brand
          name
          description
          imageUrls
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      // Check fields as per your seed data
      expect(res.body.data.listing.id).toBe(existingId);
      expect(res.body.data.listing.brand).toBe("TestBrand");
      expect(res.body.data.listing.name).toBe("TestName");
      expect(res.body.data.listing.description).toBe("A test description");
      expect(Array.isArray(res.body.data.listing.imageUrls)).toBe(true);
    });
});

it("Cant get listing by non-existent ID", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        listing(id: "10000000-b7a7-4100-8b2d-309908b444f5") {
          id
          ownerId
          brand
          name
          description
          imageUrls
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeDefined();
      expect(res.body.errors.length > 0).toBe(true);
    });
});

it("Can get all listings (paginated)", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `
        query getAllListings {
          allListings(page: 1, pageSize: 10) {
            listings {
              id
              ownerId
              brand
              name
              description
              imageUrls
            }
            totalCount
          }
        }
      `,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();

      // Now allListings is an object with { listings, totalCount }
      const data = res.body.data.allListings;
      expect(data).toBeDefined();
      expect(Array.isArray(data.listings)).toBe(true);

      // Check that we got at least one listing
      expect(data.listings.length).toBeGreaterThan(0);

      // Optionally check totalCount is a number
      expect(typeof data.totalCount).toBe("number");
      expect(data.totalCount).toBeGreaterThan(0);

      // Check a field on the first listing
      const firstListing = data.listings[0];
      expect(firstListing.id).toBeDefined();
      expect(firstListing.brand).toBeDefined();
    });
});

it("Can create a new listing", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation create {
        createListing(input: {
          ownerId: "c3769cbf-4c90-4487-bc5e-476d065b8073",
          brand: "NewBrand",
          name: "NewItem",
          description: "Brand new test item",
          imageUrls: ["http://example.com/image1.jpg","http://example.com/image2.jpg"]
        }) {
          id
          ownerId
          brand
          name
          description
          imageUrls
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      const listing = res.body.data.createListing;
      expect(listing.id).toBeDefined();
      expect(listing.ownerId).toBe("c3769cbf-4c90-4487-bc5e-476d065b8073");
      expect(listing.brand).toBe("NewBrand");
      expect(listing.name).toBe("NewItem");
      expect(listing.description).toBe("Brand new test item");
      expect(listing.imageUrls.length).toBe(2);
      createdListingId = listing.id;
    });
});

it("Can delete listing", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation delete {
        deleteListing(id: "${createdListingId}")
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      expect(res.body.data.deleteListing).toBe(true);
    });
});

it("Deleted listing should no longer exist", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        listing(id: "${createdListingId}") {
          id
          ownerId
          brand
          name
          description
          imageUrls
        }
      }`,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeDefined();
      expect(res.body.errors.length > 0).toBe(true);
    });
});

/**
 * 7) Search for listings by partial brand
 * Assuming your seed data includes a brand "TestBrand", we can search "test"
 * and expect to find at least one result.
 */
it("Can search for listings by partial brand", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `
        query search {
          searchListings(searchTerm: "test", page: 1, pageSize: 10) {
            listings {
              id
              brand
            }
            totalCount
          }
        }
      `,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();

      const data = res.body.data.searchListings;
      expect(data).toBeDefined();
      // We expect at least the "TestBrand" item
      expect(data.totalCount).toBeGreaterThan(0);
      expect(data.listings.length).toBeGreaterThan(0);

      // Check that brand includes 'TestBrand' or something similar
      // (assuming your test data includes that brand)
      const first = data.listings[0];
      expect(first.brand.toLowerCase()).toContain("test");
    });
});

/**
 * 8) Search returns empty when no matches
 */
it("Returns empty search results if no listing matches", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `
        query search {
          searchListings(searchTerm: "xyzzznotfound", page: 1, pageSize: 10) {
            listings {
              id
              brand
              name
            }
            totalCount
          }
        }
      `,
    })
    .expect(200)
    .then((res) => {
      expect(res.body.errors).toBeUndefined();
      const data = res.body.data.searchListings;
      // We expect 0 matches
      expect(data.totalCount).toBe(0);
      expect(data.listings.length).toBe(0);
    });
});

/**
 * 9) Search with pagination
 * If your DB has multiple listings that match "test", 
 * you can verify that page 1, page 2, etc. behave as expected.
 */
it("Can search with pagination", async () => {
  await supertest(server)
    .post("/graphql")
    .send({
      query: `
        query search {
          searchListings(searchTerm: "test", page: 1, pageSize: 1) {
            listings {
              id
              brand
              name
            }
            totalCount
          }
        }
      `,
    })
    .expect(200)
    .then(async (res) => {
      expect(res.body.errors).toBeUndefined();
      const data = res.body.data.searchListings;
      // totalCount might be > 1 if multiple listings match "test"
      expect(data.totalCount).toBeGreaterThanOrEqual(1);

      // We asked for pageSize = 1, so the listings array should be length 1 or 0
      expect(data.listings.length).toBeLessThanOrEqual(1);

      // If we want to test page 2, do a second query:
      const secondPageRes = await supertest(server)
        .post("/graphql")
        .send({
          query: `
            query search2 {
              searchListings(searchTerm: "test", page: 2, pageSize: 1) {
                listings {
                  id
                  brand
                  name
                }
                totalCount
              }
            }
          `,
        });
      expect(secondPageRes.body.errors).toBeUndefined();
      const secondData = secondPageRes.body.data.searchListings;
      // If totalCount > 1, page 2 might have 1 item or 0 if there's only 1 match
      if (data.totalCount > 1) {
        expect(secondData.listings.length).toBe(1);
      } else {
        expect(secondData.listings.length).toBe(0);
      }
    });
});

================
File: src/message/graphql/resolver.ts
================
// src/message/graphql/resolver.ts

import { Authorized, Query, Resolver, Ctx, Mutation, Arg } from "type-graphql";
import { Request } from "express";
import { MessageService } from "./service";
import { Message, NewMessage, UUID } from "./schema";

@Resolver()
export class MessageResolver {
  @Authorized()
  @Query(() => Message)
  async message(
    @Ctx() _req: Request,
    @Arg("input") id: UUID
  ): Promise<Message> {
    return new MessageService().getMessage(id);
  }

  @Authorized()
  @Query(() => [Message])
  async messagesByItemOwner(
    @Ctx() _req: Request,
    @Arg("input") itemOwnerId: UUID
  ): Promise<Message[]> {
    return new MessageService().getMessagesByItemOwner(itemOwnerId);
  }

  @Authorized()
  @Query(() => [Message])
  async messagesBySender(
    @Ctx() _req: Request,
    @Arg("input") senderId: UUID
  ): Promise<Message[]> {
    return new MessageService().getMessagesBySender(senderId);
  }

  @Authorized()
  @Mutation(() => Message)
  async createMessage(
    @Arg("input") messageInfo: NewMessage,
    @Ctx() _req: Request
  ): Promise<Message> {
    return new MessageService().createMessage(messageInfo);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteMessage(
    @Arg("input") messageId: UUID,
    @Ctx() _req: Request
  ): Promise<boolean> {
    return new MessageService().deleteMessage(messageId);
  }
}

================
File: src/message/graphql/schema.ts
================
//Backend/src/message/graphql/schema.ts
import { Field, InputType, ObjectType } from 'type-graphql';
import { MinLength } from 'class-validator';

/**
 * @pattern [0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}
 * @format uuid
 */
export type UUID = string;

@ObjectType()
export class Message {
  @Field()
  id!: UUID;

  @Field()
  itemOwnerId!: UUID;

  @Field()
  senderId!: UUID;

  @Field()
  @MinLength(1)
  content!: string;
}

@InputType()
export class NewMessage {
  @Field()
  itemOwnerId!: UUID;

  @Field()
  senderId!: UUID;

  @Field()
  @MinLength(1)
  content!: string;
}

================
File: src/message/graphql/service.ts
================
//Backend/src/message/graphql/service.ts
import { pool } from '../../../db';
import { NewMessage, Message, UUID } from './schema';

export class MessageService {
  public async getMessage(id: UUID): Promise<Message> {
    const select = `SELECT id, item_owner_id as "itemOwnerId", sender_id as "senderId", data->>'content' as content
    FROM message WHERE id = $1`;
    const query = {
      text: select,
      values: [id],
    };
    const { rows } = await pool.query(query);
    if (rows.length === 0) {
      return Promise.reject(new Error('Message not found.'));
    }
    return rows[0];
  }

  public async getMessagesByItemOwner(itemOwnerId: UUID): Promise<Message[]> {
    const select = `SELECT id, item_owner_id as "itemOwnerId", sender_id as "senderId", data->>'content' as content
    FROM message WHERE item_owner_id = $1`;
    const query = {
      text: select,
      values: [itemOwnerId],
    };
    const { rows } = await pool.query(query);
    return rows;
  }

  public async getMessagesBySender(senderId: UUID): Promise<Message[]> {
    const select = `SELECT id, item_owner_id as "itemOwnerId", sender_id as "senderId", data->>'content' as content
    FROM message WHERE sender_id = $1`;
    const query = {
      text: select,
      values: [senderId],
    };
    const { rows } = await pool.query(query);
    return rows;
  }

  public async createMessage(info: NewMessage): Promise<Message> {
    const insert = `INSERT INTO message(item_owner_id, sender_id, data) VALUES ($1::uuid, $2::uuid, jsonb_build_object(
      'content', $3::text
    )) RETURNING id;`;
    const query = {
      text: insert,
      values: [info.itemOwnerId, info.senderId, info.content],
    };
    const { rows } = await pool.query(query);
    return {
      id: rows[0].id,
      itemOwnerId: info.itemOwnerId,
      senderId: info.senderId,
      content: info.content,
    };
  }

  public async deleteMessage(id: UUID): Promise<boolean> {
    const del = `DELETE FROM message WHERE id = $1`;
    const query = {
      text: del,
      values: [id],
    };
    await pool.query(query);
    return true;
  }
}

================
File: src/message/test/message.test.ts
================
import * as http from "http";
import supertest from "supertest";

import { createApp } from "../../../index";
import { resetForDomain, shutdown } from "../../../test/dbTest";

let server: http.Server<
  typeof http.IncomingMessage,
  typeof http.ServerResponse
>;

beforeAll(async () => {
  // 1) Clear + seed domain's DB
  await resetForDomain("message");

  // 2) Start the app
  const app = await createApp();
  server = http.createServer(app);
  server.listen(0);
}, 10000);

afterAll((done) => {
  shutdown(() => {
    server.close(done);
  });
});

let createdMessageId = "";
const existingItemOwnerId = "00000000-b7a7-4100-8b2d-309908b444f5"; // Adjust as needed
const existingSenderId = "c3769cbf-4c90-4487-bc5e-476d065b8073"; // Adjust as needed

it("Can create a new message", async () => {
  const res = await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation create {
        createMessage(input: {
          itemOwnerId: "${existingItemOwnerId}",
          senderId: "${existingSenderId}",
          content: "Hello, is this item still available?"
        }) {
          id
          itemOwnerId
          senderId
          content
        }
      }`,
    })
    .expect(200);

  expect(res.body.errors).toBeUndefined();
  const msg = res.body.data.createMessage;
  expect(msg.id).toBeDefined();
  expect(msg.itemOwnerId).toBe(existingItemOwnerId);
  expect(msg.senderId).toBe(existingSenderId);
  expect(msg.content).toBe("Hello, is this item still available?");
  createdMessageId = msg.id;
});

it("Can get message by ID", async () => {
  const res = await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        message(input: "${createdMessageId}") {
          id
          itemOwnerId
          senderId
          content
        }
      }`,
    })
    .expect(200);

  expect(res.body.errors).toBeUndefined();
  const msg = res.body.data.message;
  expect(msg.id).toBe(createdMessageId);
  expect(msg.itemOwnerId).toBe(existingItemOwnerId);
  expect(msg.senderId).toBe(existingSenderId);
  expect(msg.content).toBe("Hello, is this item still available?");
});

it("Can get messages by itemOwnerId", async () => {
  const res = await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        messagesByItemOwner(input: "${existingItemOwnerId}") {
          id
          itemOwnerId
          senderId
          content
        }
      }`,
    })
    .expect(200);

  expect(res.body.errors).toBeUndefined();
  const msgs = res.body.data.messagesByItemOwner;
  expect(Array.isArray(msgs)).toBe(true);
  expect(msgs.length).toBeGreaterThan(0);
  // Check if the created message is among them
  expect(msgs.some((m: any) => m.id === createdMessageId)).toBe(true);
});

it("Can get messages by senderId", async () => {
  const res = await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        messagesBySender(input: "${existingSenderId}") {
          id
          itemOwnerId
          senderId
          content
        }
      }`,
    })
    .expect(200);

  expect(res.body.errors).toBeUndefined();
  const msgs = res.body.data.messagesBySender;
  expect(Array.isArray(msgs)).toBe(true);
  expect(msgs.length).toBeGreaterThan(0);
  expect(msgs.some((m: any) => m.id === createdMessageId)).toBe(true);
});

it("Cant get message by non-existent ID", async () => {
  const res = await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        message(input: "10000000-b7a7-4100-8b2d-309908b444f5") {
          id
          itemOwnerId
          senderId
          content
        }
      }`,
    })
    .expect(200);

  expect(res.body.errors).toBeDefined();
  expect(res.body.errors.length > 0).toBe(true);
});

it("Can delete message", async () => {
  const res = await supertest(server)
    .post("/graphql")
    .send({
      query: `mutation del {
        deleteMessage(input: "${createdMessageId}")
      }`,
    })
    .expect(200);

  expect(res.body.errors).toBeUndefined();
  expect(res.body.data.deleteMessage).toBe(true);
});

it("Deleted message should no longer exist", async () => {
  const res = await supertest(server)
    .post("/graphql")
    .send({
      query: `query get {
        message(input: "${createdMessageId}") {
          id
          itemOwnerId
          senderId
          content
        }
      }`,
    })
    .expect(200);

  expect(res.body.errors).toBeDefined();
  expect(res.body.errors.length > 0).toBe(true);
});

================
File: src/orders/graphql/resolver.ts
================
// src/orders/graphql/resolver.ts

import { Authorized, Resolver, Query, Mutation, Arg } from "type-graphql";
import { OrderService } from "./service";
import { Order, NewOrder, UUID, ShippingStatus } from "./schema";

@Resolver()
export class OrderResolver {
  private readonly orderService = new OrderService();

  @Authorized()
  @Query(() => Order)
  async order(@Arg("id") id: UUID): Promise<Order> {
    return this.orderService.getOrder(id);
  }

  @Authorized()
  @Query(() => [Order])
  async allOrders(): Promise<Order[]> {
    return this.orderService.getAllOrders();
  }

  @Authorized()
  @Mutation(() => Order)
  async createOrder(@Arg("input") input: NewOrder): Promise<Order> {
    return this.orderService.createOrder(input);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async deleteOrder(@Arg("id") id: UUID): Promise<boolean> {
    return this.orderService.deleteOrder(id);
  }

  @Authorized()
  @Mutation(() => Boolean)
  async updateOrderStatus(
    @Arg("id") id: UUID,
    @Arg("status", () => ShippingStatus) status: ShippingStatus
  ): Promise<boolean> {
    return this.orderService.updateShippingStatus(id, status);
  }
}

================
File: src/orders/graphql/schema.ts
================
//Backend/src/orders/graphql/schema.ts
import { Field, InputType, ObjectType, registerEnumType } from "type-graphql";
import { MinLength } from "class-validator";

/**
 * From your listing schema example:
 * @pattern [0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}
 * @format uuid
 */
export type UUID = string;

/**
 * Example shipping statuses. Feel free to add or change these.
 */
export enum ShippingStatus {
  PENDING = "PENDING",
  SHIPPED = "SHIPPED",
  DELIVERED = "DELIVERED",
  CANCELLED = "CANCELLED",
}

/**
 * Let TypeGraphQL know about our enum so it can generate correct schema types.
 */
registerEnumType(ShippingStatus, {
  name: "ShippingStatus",
});

@ObjectType()
export class Order {
  @Field()
  id!: UUID;

  // The account who placed the order
  @Field()
  buyerId!: UUID;

  // The account fulfilling the order (e.g. vendor or seller)
  @Field()
  sellerId!: UUID;

  @Field()
  itemId!: UUID;

  // Current shipping status of the order
  @Field(() => ShippingStatus)
  shippingStatus!: ShippingStatus;

  // Optionally store extra info
  // e.g., items, addresses, timestamps, etc.
  @Field({ nullable: true })
  data?: string;
}

@InputType()
export class NewOrder {
  @Field()
  buyerId!: UUID;

  @Field()
  sellerId!: UUID;

  @Field()
  itemId!: UUID; // ensure you capture itemId if needed

  @Field(() => ShippingStatus, { nullable: true })
  shippingStatus?: ShippingStatus;

  @Field({ nullable: true })
  @MinLength(1)
  data?: string;
}

================
File: src/orders/graphql/service.ts
================
//Backend/src/orders/graphql/service.ts
import { pool } from '../../../db';
import { NewOrder, Order, ShippingStatus, UUID } from './schema';

export class OrderService {
  /**
   * Fetch a single order by id.
   */
  public async getOrder(id: UUID): Promise<Order> {
    const select = `
      SELECT
        id,
        buyer_id,
        seller_id,
        item_id,
        shipping_status,
        data
      FROM orders
      WHERE id = $1
    `;
    const query = {
      text: select,
      values: [id],
    };
    const { rows } = await pool.query(query);

    if (rows.length === 0) {
      throw new Error('Order with given ID does not exist.');
    }

    // Convert row to Order object
    const row = rows[0];
    return {
      id: row.id,
      buyerId: row.buyer_id,
      sellerId: row.seller_id,
      itemId: row.item_id,
      shippingStatus: row.shipping_status as ShippingStatus,
      data: row.data || undefined,
    };
  }

  /**
   * Fetch all orders in the system (or optionally filter).
   */
  public async getAllOrders(): Promise<Order[]> {
    const select = `
      SELECT
        id,
        buyer_id,
        seller_id,
        item_id,
        shipping_status,
        data
      FROM orders
    `;
    const { rows } = await pool.query(select);

    return rows.map((row) => ({
      id: row.id,
      buyerId: row.buyer_id,
      sellerId: row.seller_id,
      itemId: row.item_id,
      shippingStatus: row.shipping_status as ShippingStatus,
      data: row.data || undefined,
    }));
  }

  /**
   * Create a new order in the DB.
   * shippingStatus defaults to 'PENDING' if not provided.
   */
  public async createOrder(info: NewOrder): Promise<Order> {
    const status = info.shippingStatus || ShippingStatus.PENDING;
    
    const insert = `
      INSERT INTO orders (buyer_id, seller_id, shipping_status, item_id, data)
      VALUES ($1::uuid, $2::uuid, $3::text, $4::uuid, $5::jsonb)
      RETURNING id
    `;
    const query = {
      text: insert,
      values: [
        info.buyerId,
        info.sellerId,
        status,
        info.itemId, // <--- pass the itemId now
        info.data ? JSON.stringify(info.data) : null,
      ],
    };
    
    const { rows } = await pool.query(query);
    const id = rows[0].id as UUID;
  
    return {
      id,
      buyerId: info.buyerId,
      sellerId: info.sellerId,
      itemId: info.itemId,
      shippingStatus: status,
      data: info.data,
    };
  }

  /**
   * Delete an order by id.
   * Returns true if deleted successfully, false if not found (optional).
   */
  public async deleteOrder(id: UUID): Promise<boolean> {
    const del = `
      DELETE FROM orders
      WHERE id = $1
    `;
    const query = {
      text: del,
      values: [id],
    };

    const result = await pool.query(query);
    // result.rowCount === 1 if a row was deleted
    return result.rowCount === 1;
  }

  /**
   * Update the shipping status for a given order.
   */
  public async updateShippingStatus(
    id: UUID,
    newStatus: ShippingStatus
  ): Promise<boolean> {
    const update = `
      UPDATE orders
      SET shipping_status = $2
      WHERE id = $1
    `;
    const query = {
      text: update,
      values: [id, newStatus],
    };

    const result = await pool.query(query);
    return result.rowCount === 1; // true if an order was updated
  }
}

================
File: src/orders/test/order.test.ts
================
// file: Backend/src/order/test/order.test.ts
import * as http from "http";
import supertest from "supertest";
import { createApp } from "../../../index";
import { resetForDomain, shutdown } from "../../../test/dbTest";

/**
 * We'll store created order IDs here so we can test updates/deletions.
 */
let orderId = "";

let server: http.Server<typeof http.IncomingMessage, typeof http.ServerResponse>;

beforeAll(async () => {
  // 1) Clear + seed domain’s DB (recreates the "order" table, etc.)
  await resetForDomain("orders");

  // 2) Start the app on a random port
  const app = await createApp();
  server = http.createServer(app);
  server.listen(0);
}, 10000);

afterAll((done) => {
  // Shut down the shared DB pool + close server
  shutdown(() => {
    server.close(done);
  });
});

describe("Order Tests", () => {
  it("Can create a new order", async () => {
    const buyerId = "00000000-b7a7-4100-8b2d-309908b444f5";
    const sellerId = "c3769cbf-4c90-4487-bc5e-476d065b8073";
    const itemId = '33333333-aaaa-bbbb-cccc-444444444444'
    const mutation = `
      mutation create {
        createOrder(input: {
          buyerId: "${buyerId}",
          sellerId: "${sellerId}",
          itemId: "${itemId}",
          shippingStatus: PENDING,
          data: "LineItems or JSON data"
        }) {
          id
          buyerId
          sellerId
          shippingStatus
          data
        }
      }
    `;

    await supertest(server)
      .post("/graphql")
      .send({ query: mutation })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const created = res.body.data.createOrder;
        expect(created).toBeDefined();
        expect(created.buyerId).toBe(buyerId);
        expect(created.sellerId).toBe(sellerId);
        expect(created.shippingStatus).toBe("PENDING");
        expect(created.data).toBe("LineItems or JSON data");

        orderId = created.id; // Store for subsequent tests
      });
  });

  it("Can fetch order by id", async () => {
    const query = `
      query get {
        order(id: "${orderId}") {
          id
          buyerId
          sellerId
          shippingStatus
          data
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .send({ query })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const fetched = res.body.data.order;
        expect(fetched).toBeDefined();
        expect(fetched.id).toBe(orderId);
      });
  });

  it("Can update shipping status", async () => {
    const mutation = `
      mutation update {
        updateOrderStatus(id: "${orderId}", status: SHIPPED)
      }
    `;
    await supertest(server)
      .post("/graphql")
      .send({ query: mutation })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        // updateOrderStatus returns boolean
        expect(res.body.data.updateOrderStatus).toBe(true);
      });

    // Verify that shippingStatus is indeed updated
    const checkQuery = `
      query check {
        order(id: "${orderId}") {
          id
          shippingStatus
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .send({ query: checkQuery })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.order.shippingStatus).toBe("SHIPPED");
      });
  });

  it("Can fetch all orders", async () => {
    const query = `
      query getAll {
        allOrders {
          id
          buyerId
          sellerId
          shippingStatus
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .send({ query })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        const orders = res.body.data.allOrders;
        expect(Array.isArray(orders)).toBe(true);
        // We expect at least 1, the one we created
        expect(orders.length).toBeGreaterThan(0);
        // Check that our created order is in there
        const found = orders.find((o: any) => o.id === orderId);
        expect(found).toBeDefined();
      });
  });

  it("Can delete an order", async () => {
    const mutation = `
      mutation remove {
        deleteOrder(id: "${orderId}")
      }
    `;
    await supertest(server)
      .post("/graphql")
      .send({ query: mutation })
      .expect(200)
      .then((res) => {
        expect(res.body.errors).toBeUndefined();
        expect(res.body.data.deleteOrder).toBe(true);
      });

    // Check that the order no longer exists
    const checkQuery = `
      query check {
        order(id: "${orderId}") {
          id
        }
      }
    `;
    await supertest(server)
      .post("/graphql")
      .send({ query: checkQuery })
      .expect(200)
      .then((res) => {
        // Now it should have an error because the order doesn't exist
        expect(res.body.errors).toBeDefined();
        expect(res.body.errors.length).toBeGreaterThan(0);
      });
  });
});

================
File: test/account/testdata/data.sql
================
-- 3.data.sql

INSERT INTO account (email, data, restricted)
VALUES 
  (
    'test@example.com',
    jsonb_build_object(
      'password', crypt('password', 'hello'),
      'name', jsonb_build_object('first','John','last','Doe'),
      'username': 'deez'
      'roles', jsonb_build_array('admin')
    ),
    false
  ),
  (
    'janet@example.com',
    jsonb_build_object(
      'password', crypt('secret', 'hello'),
      'name', jsonb_build_object('first','Jane','last','Smith'),
      'roles', jsonb_build_array('user')
    ),
    false
  ),
  (
    'market@example.com',
    jsonb_build_object(
      'password', crypt('mypassword', 'hello'),
      'name', jsonb_build_object('first','Mark','last','Johnson'),
      'roles', jsonb_build_array('user','editor')
    ),
    false
  );

INSERT INTO account(id, email, data) VALUES ('00000000-b7a7-4100-8b2d-309908b444f5', 'sammy@slugmart.com', jsonb_build_object(    'name', jsonb_build_object(        'first', 'Sammy',       'last', 'Slug'),    'password', crypt('sammyslug', 'DCozzICfOJVtSpwH'),    'roles', '["Shopper","Vendor","Admin"]'::jsonb));
INSERT INTO account(id, email, data) VALUES ('c3769cbf-4c90-4487-bc5e-476d065b8073', 'santiago@sales.com', jsonb_build_object(    'name', jsonb_build_object(        'first', 'Santiago',       'last', 'Salesman'),    'password', crypt('sammysalesman', 'DCozzICfOJVtSpwH'),    'roles', '["Vendor"]'::jsonb));
INSERT INTO account(id, email, data) VALUES ('0c9cd742-bb6c-49d1-9a32-a025249e6357', 'veronica@vendor.com', jsonb_build_object(    'name', jsonb_build_object(        'first', 'Veronica',       'last', 'Vendor'),    'password', crypt('veronicavendor', 'DCozzICfOJVtSpwH'),    'roles', '["Vendor"]'::jsonb));

================
File: test/account/testdata/schema.sql
================
-- 2.schema.sql
-- Enable pgcrypto for UUID generation and crypt()
CREATE EXTENSION IF NOT EXISTS pgcrypto;

DROP TABLE IF EXISTS account CASCADE;
-- Create the account table
CREATE TABLE account (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text UNIQUE NOT NULL,
  data jsonb NOT NULL,
  restricted boolean NOT NULL DEFAULT false
);

================
File: test/auth/testdata/data.sql
================
-- 3.data.sql

INSERT INTO account (email, data, restricted)
VALUES 
  (
    'test@example.com',
    jsonb_build_object(
      'password', crypt('password', 'hello'),
      'name', jsonb_build_object('first','John','last','Doe'),
      'roles', jsonb_build_array('admin')
    ),
    false
  ),
  (
    'janet@example.com',
    jsonb_build_object(
      'password', crypt('secret', 'hello'),
      'name', jsonb_build_object('first','Jane','last','Smith'),
      'roles', jsonb_build_array('user')
    ),
    false
  ),
  (
    'market@example.com',
    jsonb_build_object(
      'password', crypt('mypassword', 'hello'),
      'name', jsonb_build_object('first','Mark','last','Johnson'),
      'roles', jsonb_build_array('user','editor')
    ),
    false
  );

================
File: test/auth/testdata/schema.sql
================
-- 2.schema.sql
-- Enable pgcrypto for UUID generation and crypt()
CREATE EXTENSION IF NOT EXISTS pgcrypto;

DROP TABLE IF EXISTS account CASCADE;
-- Create the account table
CREATE TABLE account (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text UNIQUE NOT NULL,
  data jsonb NOT NULL,
  restricted boolean NOT NULL DEFAULT false
);

================
File: test/listing/testdata/data.sql
================
-- Insert the specific listing your "Can get listing by ID" test expects:
-- 00000000-b7a7-4100-8b2d-309908b444f5
INSERT INTO listing (id, owner_id, data)
VALUES (
  '00000000-b7a7-4100-8b2d-309908b444f5',
  '11111111-1111-1111-1111-111111111111',
  jsonb_build_object(
    'brand', 'TestBrand',
    'name', 'TestName',
    'description', 'A test description',
    'imageUrls', ARRAY['http://example.com/image.jpg']
  )
)
ON CONFLICT (id) DO NOTHING;

-- Insert a second listing also containing "test" in brand/description,
-- ensuring "searchListings" can return multiple matches for "test".
INSERT INTO listing (id, owner_id, data)
VALUES (
  '11111111-b7a7-4100-8b2d-309908b444f5',
  '11111111-1111-1111-1111-111111111111',
  jsonb_build_object(
    'brand', 'TestBrand2',
    'name', 'AnotherItem',
    'description', 'Another test description',
    'imageUrls', ARRAY['http://example.com/image2.jpg']
  )
)
ON CONFLICT (id) DO NOTHING;

-- Insert a third listing that DOES NOT have the word "test" anywhere,
-- so your negative search test can confirm zero results for queries like "xyzzznotfound".
INSERT INTO listing (id, owner_id, data)
VALUES (
  '22222222-b7a7-4100-8b2d-309908b444f5',
  '11111111-1111-1111-1111-111111111111',
  jsonb_build_object(
    'brand', 'UniqueBrand',
    'name', 'DifferentItem',
    'description', 'Does not contain test keyword',
    'imageUrls', ARRAY['http://example.com/image3.jpg']
  )
)
ON CONFLICT (id) DO NOTHING;

================
File: test/listing/testdata/schema.sql
================
-- 2.schema.sql
-- Enable pgcrypto for UUID generation and crypt()
CREATE EXTENSION IF NOT EXISTS pgcrypto;

DROP TABLE IF EXISTS listing CASCADE;

CREATE TABLE listing (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id uuid NOT NULL,
  data jsonb NOT NULL
);

================
File: test/message/testdata/data.sql
================
INSERT INTO message (id, item_owner_id, sender_id, data)
VALUES (
  '00000000-b7a7-4100-8b2d-309908b444f5',
  '00000000-b7a7-4100-8b2d-309908b444f5',
  'c3769cbf-4c90-4487-bc5e-476d065b8073',
  jsonb_build_object('content', 'Initial test message')
);

================
File: test/message/testdata/schema.sql
================
CREATE EXTENSION IF NOT EXISTS pgcrypto;

DROP TABLE IF EXISTS message CASCADE;

CREATE TABLE message (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  item_owner_id uuid NOT NULL,
  sender_id uuid NOT NULL,
  data jsonb NOT NULL
);

================
File: test/orders/testdata/data.sql
================
-- test data in Backend/test/orders/testdata/data.sql
-- Insert some sample orders referencing existing accounts

INSERT INTO orders (id, buyer_id, seller_id, shipping_status, item_id, data)
VALUES
  (
    '11111111-aaaa-bbbb-cccc-222222222222',
    '00000000-b7a7-4100-8b2d-309908b444f5',
    'c3769cbf-4c90-4487-bc5e-476d065b8073',
    'PENDING',
    '33333333-aaaa-bbbb-cccc-444444444444',  -- example itemId
    jsonb_build_object('notes', 'Sample seeded order #1')
  ),
  (
    '22222222-aaaa-bbbb-cccc-333333333333',
    '0c9cd742-bb6c-49d1-9a32-a025249e6357',
    '00000000-b7a7-4100-8b2d-309908b444f5',
    'SHIPPED',
    '55555555-aaaa-bbbb-cccc-666666666666',  -- itemId
    jsonb_build_object('notes', 'Sample seeded order #2')
  );

================
File: test/orders/testdata/schema.sql
================
-- 2.schema.sql
-- Enable pgcrypto for UUID generation and crypt()
CREATE EXTENSION IF NOT EXISTS pgcrypto;

DROP TABLE IF EXISTS account CASCADE;
-- Create the account table
CREATE TABLE account (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text UNIQUE NOT NULL,
  data jsonb NOT NULL,
  restricted boolean NOT NULL DEFAULT false
);

DROP TABLE IF EXISTS listing CASCADE;

CREATE TABLE listing (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id uuid NOT NULL,
  data jsonb NOT NULL
);

DROP TABLE IF EXISTS message CASCADE;

CREATE TABLE message (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  item_owner_id uuid NOT NULL,
  sender_id uuid NOT NULL,
  data jsonb NOT NULL
);

DROP TABLE IF EXISTS orders CASCADE;

CREATE TABLE orders (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- The account who placed the order
  buyer_id uuid NOT NULL,
  
  -- The account (shop or seller) fulfilling the order
  seller_id uuid NOT NULL,
  
  -- For now, we’ll store an order or shipping status as a simple text column
  shipping_status text NOT NULL DEFAULT 'pending',

  item_id uuid NOT NULL,
  
  -- Possibly a JSONB for extra data (items, totals, addresses, etc.)
  data jsonb

);

================
File: test/dbTest.ts
================
import { Pool } from 'pg';
import dotenv from 'dotenv';
import * as fs from 'fs';
import * as path from 'path';

dotenv.config();

export const pool = new Pool({
  connectionString: process.env.DATABASE_URL,  // points to your test DB
});

/**
 * Helper to run any .sql file from a specific path.
 */
async function runSqlFile(filePath: string) {
  const content = fs.readFileSync(filePath, 'utf8');
  await pool.query(content);
  console.log(`Executed SQL file: ${filePath}`);
}

/**
 * Each domain can have its own subfolder or .sql files, and we can run them in sequence.
 */
export async function resetForDomain(domain: string): Promise<void> {
  // Example: run domain’s schema + data if they exist
  const domainPath = path.join(__dirname, domain, 'testdata'); 
  const schemaFile = path.join(domainPath, 'schema.sql');
  const dataFile = path.join(domainPath, 'data.sql');

  // If domain has a schema.sql, run it
  if (fs.existsSync(schemaFile)) {
    await runSqlFile(schemaFile);
  }
  // If domain has a data.sql, run it
  if (fs.existsSync(dataFile)) {
    await runSqlFile(dataFile);
  }
}

/**
 * Optionally, run a global schema/data if you want to seed common tables first
 */
export async function resetGlobal(): Promise<void> {
  // If you have a top-level testdata folder
  const globalPath = path.join(__dirname, 'testdata');
  const schemaFile = path.join(globalPath, 'schema.sql');
  const dataFile = path.join(globalPath, 'data.sql');

  if (fs.existsSync(schemaFile)) {
    await runSqlFile(schemaFile);
  }
  if (fs.existsSync(dataFile)) {
    await runSqlFile(dataFile);
  }
}

/**
 * Shut down the pool entirely.
 */
export function shutdown(done: Function) {
  pool.end(() => {
    done();
  });
}

================
File: babel.config.js
================
// microservices/auth/babel.config.js
module.exports = {
    presets: [
      ['@babel/preset-env', { targets: { node: 'current' } }], 
      '@babel/preset-typescript'
    ],
  };

================
File: db.ts
================
import { Pool } from 'pg';
import dotenv from 'dotenv';
dotenv.config();

console.log(process.env.DATABASE_URL);

export const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
  });

================
File: index.ts
================
// Backend/index.ts

import dotenv from "dotenv";
import express, { Request, Response, NextFunction } from "express";
import helmet from "helmet";
import { createHandler } from "graphql-http/lib/use/express";
import { Pool } from "pg";
import "reflect-metadata";
import { buildSchema, AuthChecker } from "type-graphql";
import * as jwt from "jsonwebtoken";
dotenv.config();

// Import all resolvers
import { AccountResolver } from "./src/account/graphql/resolver";
import { AuthResolver } from "./src/auth/graphql/resolver";
import { ListingResolver } from "./src/listing/graphql/resolver";
import { MessageResolver } from "./src/message/graphql/resolver";
import { OrderResolver } from "./src/orders/graphql/resolver";

// Create a single database pool
export const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

/**
 * Global auth checker for TypeGraphQL.
 * If the request query contains login or makeAccount, authentication is skipped.
 * Otherwise, the token is extracted from the Authorization header and verified.
 */
const customAuthChecker: AuthChecker<any> = ({ context }, roles) => {
  if (context.req.body && typeof context.req.body.query === "string") {
    if (/(\blogin\b)|(\bmakeAccount\b)/i.test(context.req.body.query)) {
      return true;
    }
  }
  const authHeader = context.req.headers.authorization;
  if (!authHeader) {
    return false;
  }
  const token = authHeader.split(" ")[1];
  try {
    const decoded = jwt.verify(token, process.env.MASTER_SECRET as string) as { id: string };
    // Optionally attach the user id to the context
    context.userId = decoded.id;
    return true;
  } catch (err) {
    return false;
  }
};

/**
 * Builds the GraphQL schema using all resolvers and our custom authChecker.
 */
async function createSchema() {
  return await buildSchema({
    resolvers: [AuthResolver, AccountResolver, ListingResolver, MessageResolver, OrderResolver],
    authChecker: customAuthChecker,
  });
}

/**
 * Creates and configures the Express app.
 * Sets secure headers, parses JSON bodies, enforces global authentication (except on public operations),
 * and mounts the GraphQL endpoint.
 */
export async function createApp() {
  // Test database connection
  const client = await pool.connect();
  const res = await client.query("SELECT NOW()");
  client.release();
  console.log("Connected to database, current time:", res.rows[0].now);

  // Build the schema
  const schema = await createSchema();

  // Create the Express app
  const app = express();

  // Set secure HTTP headers with Helmet
  app.use(helmet());

  // Parse incoming JSON bodies
  app.use(express.json());

  // Custom authentication middleware for /graphql:
  // Allow login and makeAccount operations even without a token.
  app.use(
    "/graphql",
    ((req: Request, res: Response, next: NextFunction): void | Response => {
      if (req.body && typeof req.body.query === "string") {
        if (/(\blogin\b)|(\bmakeAccount\b)/i.test(req.body.query)) {
          return next();
        }
      }
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ errors: [{ message: "Not authenticated" }] });
      }
      const token = authHeader.split(" ")[1];
      try {
        jwt.verify(token, process.env.MASTER_SECRET as string);
        next();
      } catch (err) {
        return res.status(401).json({ errors: [{ message: "Invalid token" }] });
      }
    }) as express.RequestHandler
  );

  // Mount the GraphQL endpoint
  app.all(
    "/graphql",
    createHandler({
      schema,
    })
  );

  return app;
}

/**
 * If this file is run directly, start the server on port 4000.
 */
if (require.main === module) {
  createApp()
    .then((app) => {
      app.listen(4000, () => {
        console.log("Running a GraphQL API server at http://localhost:4000/graphql");
      });
    })
    .catch((err) => {
      console.error("Failed to start server", err);
    });
}

================
File: jest.config.js
================
// microservices/auth/jest.config.js
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    rootDir: './',
    //testMatch: ['<rootDir>/src/test/*.test.ts'],
    moduleFileExtensions: ['ts', 'js'],
    transform: {
        '^.+\\.(ts|tsx)$': [
            'ts-jest',
            { 
                tsconfig: 'tsconfig.json'
            }
        ],
        // This line allows Babel to transform ESM in node_modules
        '^.+\\.(js|mjs)$': 'babel-jest',
    },
    testPathIgnorePatterns: [
        "/node_modules/",
        "/dist/"
      ],
    transformIgnorePatterns: [
        // Override default to allow graphql-request to be transformed
        'node_modules/(?!graphql-request)'
    ],

};

================
File: package.json
================
{
  "name": "vintain-backend",
  "version": "1.0.0",
  "description": "",
  "main": "dist/index.js",
  "scripts": {
    "dev": "ts-node src/index.ts",
    "build": "tsc",
    "start": "tsc && node dist/index.js",
    "test": "npm run test:auth && npm run test:account && npm run test:listing && npm run test:message",
    "test:auth": "jest --config jest.config.js --testPathPattern='src/auth/test/' --runInBand",
    "test:account": "jest --config jest.config.js --testPathPattern='src/account/test/' --runInBand",
    "test:listing": "jest --config jest.config.js --testPathPattern='src/listing/test/' --runInBand",
    "test:message": "jest --config jest.config.js --testPathPattern='src/message/test/' --runInBand",
    "test:orders": "jest --config jest.config.js --testPathPattern='src/orders/test/' --runInBand"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "class-validator": "^0.14.1",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "graphql": "^16.10.0",
    "graphql-http": "^1.22.3",
    "graphql-request": "^7.1.2",
    "helmet": "^8.0.0",
    "http": "^0.0.1-security",
    "jsonwebtoken": "^9.0.2",
    "pg": "^8.13.1",
    "reflect-metadata": "^0.2.2",
    "supertest": "^7.0.0",
    "type-graphql": "^2.0.0-rc.2"
  },
  "devDependencies": {
    "@babel/preset-env": "^7.26.0",
    "@babel/preset-typescript": "^7.26.0",
    "@types/express": "^5.0.0",
    "@types/graphql": "^14.5.0",
    "@types/jest": "^29.5.14",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/node": "^22.10.2",
    "@types/pg": "^8.11.10",
    "@types/supertest": "^6.0.2",
    "jest": "^29.7.0",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.7.2"
  }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2021",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,

    // For NestJS/TypeGraphQL/other decorators
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,

    // Keep your life simpler
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,

    // Where compiled JS goes
    "outDir": "dist",

    // The root where TS looks for source .ts files
    // '.' means "the same directory as tsconfig.json"
    "rootDir": "."
  },

  // Tell TypeScript which files/folders to include
  // Here we say "any .ts file in any subfolder"
  "include": [
    "**/*.ts"
  ],

  // Usually exclude node_modules and the dist build folder
  "exclude": [
    "node_modules",
    "dist"
  ]
}
